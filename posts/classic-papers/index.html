<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Reading List for the mindful Software Engineer | Daniel's programming rants</title><meta name=keywords content="programming"><meta name=description content="Abstractions are essential in order to build complex systems and keep complexity under control. Especially in software development we rely on many abstractions to make our life easier. Although good abstractions do not &ldquo;leak&rdquo;, it&rsquo;s always helpful to understand the background and the details behind them.
The following list (in chronological order) of classic computer science papers will give you insights of inventions of the last decades which are considered nowadays common sense."><meta name=author content="Daniel Gerlach"><link rel=canonical href=https://gerlacdt.github.io/posts/classic-papers/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4BE9J0ZRDL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4BE9J0ZRDL",{anonymize_ip:!1})}</script><meta property="og:title" content="Reading List for the mindful Software Engineer"><meta property="og:description" content="Abstractions are essential in order to build complex systems and keep complexity under control. Especially in software development we rely on many abstractions to make our life easier. Although good abstractions do not &ldquo;leak&rdquo;, it&rsquo;s always helpful to understand the background and the details behind them.
The following list (in chronological order) of classic computer science papers will give you insights of inventions of the last decades which are considered nowadays common sense."><meta property="og:type" content="article"><meta property="og:url" content="https://gerlacdt.github.io/posts/classic-papers/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-10T10:04:01+01:00"><meta property="article:modified_time" content="2021-09-10T10:04:01+01:00"><meta property="og:site_name" content="Daniel's programming rants"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reading List for the mindful Software Engineer"><meta name=twitter:description content="Abstractions are essential in order to build complex systems and keep complexity under control. Especially in software development we rely on many abstractions to make our life easier. Although good abstractions do not &ldquo;leak&rdquo;, it&rsquo;s always helpful to understand the background and the details behind them.
The following list (in chronological order) of classic computer science papers will give you insights of inventions of the last decades which are considered nowadays common sense."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://gerlacdt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Reading List for the mindful Software Engineer","item":"https://gerlacdt.github.io/posts/classic-papers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reading List for the mindful Software Engineer","name":"Reading List for the mindful Software Engineer","description":"Abstractions are essential in order to build complex systems and keep complexity under control. Especially in software development we rely on many abstractions to make our life easier. Although good abstractions do not \u0026ldquo;leak\u0026rdquo;, it\u0026rsquo;s always helpful to understand the background and the details behind them.\nThe following list (in chronological order) of classic computer science papers will give you insights of inventions of the last decades which are considered nowadays common sense.","keywords":["programming"],"articleBody":"Abstractions are essential in order to build complex systems and keep complexity under control. Especially in software development we rely on many abstractions to make our life easier. Although good abstractions do not “leak”, it’s always helpful to understand the background and the details behind them.\nThe following list (in chronological order) of classic computer science papers will give you insights of inventions of the last decades which are considered nowadays common sense. But back then, even the most basic concepts needed to be invented or discovered. I find it fascinating how much you can learn from the discovery of such breakthroughs and I hope you can learn from them as much as I did. Further it is quite satisfactory when one is able to connect the dots from the past to the present. Knowing the history prevent you from reinventing the wheel and from making same failures over and over again:\n Those that fail to learn from history are doomed to repeat it.\n by Winston Churchill\nRecursive Functions of Symbolic Expressions and Their Computations by Machine, Part I by John McCarthy 1960\nLink to paper\nThis paper is special in it’s own ways and is widely considered as a seminal work of computer science.\nJohn McCarthy defines the complete LISP programming language in roughly 30 pages. The design of Lisp with S-expressions is ingenious because it’s so simple. 1960 most of the programming language concepts, which we consider basic today, needed to be defined. McCarthy does this on the go. He introduces conditional expressions like if-then-else. Those are needed for recursive functions in order to formulate the recursion termination condition. Casually he also introduces the first garbage-collection algorithm with a free-storage-list. All in one paper, groundbreaking!\nUnfortunately the paper is hard to “digest” due to its age. A contemporary and more comprehensible essay was written by Paul Graham, The Roots of Lisp. Graham picks up McCarthy’s paper and brings it in a more readable form.\nOn the Criteria To Be Used in Decomposing Systems into Modules  by David Parnas 1972\nLink to paper\nToday, we know modularization is a keystone for building large software systems. Independent and autonomous teams are critical. To achieve autonomy and smooth collaboration, modules must hide their internal implementation, i.e. they should only expose the least information which is absolutely necessary. The concept advocated by Parnas is information hiding. It is crucial to encapsulate the module’s internals, so consumers do not have to deal with the module’s internal complexity. Parnas summarizes:\n The benefits expected of modular programming are: (1) managerial-development time should be shortened because separate groups would work on each module with little need for communication: (2) product flexibility - it should be possible to make drastic changes to one module without a need to change others; (3) comprehensibility - it should be possible to study the system one module at a time. The whole system can therefore be better designed because it is better understood.\n The principle of information hiding enables us to replace an existing implementation but to keep the exposed interface. Hence existing consumers remain untouched. Further modules can be reused and provide their functionality safely. Basically Parnas paved the way for APIs which are one of the most influential and powerful concepts of software engineering. APIs act as contracts between consumer and producer. This is true in the small scope for software libraries but also in a large scope for REST-APIs, gRPC and the like. Modularization is a precondition for Microservices whose functionality is hidden between a well-defined and documented API. Even the Unix Philosophy is a “just” a description for a good module:\n Do one thing well Write programs that work together Write programs to handle text streams, because that is a universal interface.  Historical fact: In the seventies information hiding was controversial. Even the most renowned IT people like Fred Brooks who managed the development of IBM’s System/360 with thousands of people and a budget of 5 billion dollars did not believe in it. Years later Brooks admitted (after bitter learnings):\n David Parnas Was Right, and I Was Wrong About Information Hiding.\n The Mythical Man-Month: Essays on Software Engineering by Fred Brooks 1975\nLink to book\nFred Brooks “Essays on Software Engineering” are from the seventies but many of his insights still hold up today. 50 years are an eternity in the IT field and it speaks for the quality of this seminal book.\nIn his essay The Mythical Man-Month, he directly addresses software project management fallacies and bad estimations. Developers are not line workers but creative problem solvers - increasing their numbers will not positively impact the project’s progress.\n Adding manpower to a late software project makes it later.\n  Nine women can’t make a baby in one month\n Many other terms are coined in his essays. He muses that there is No Silver Bullet, i.e. no new technology or process that will improve productivity by an order of magnitude. He also addresses the tendency towards over-engineering in the Second System effect and warns about its consequences.\n The second system is most dangerous system a man ever designs … The general tendency is to over-design the second system, using all ideas and frills that were cautiously sidetracked on the first one.\n Further, he advocates for small, independent teams. The surgical team, is a team with 5-10 people and cross-functional skills. Sounds familiar Agile community?\nTime, Clocks, and the Ordering of Events in a Distributed System by Leslie Lamport 1978\nLink to paper\nThe seminal paper about logical clocks or Lamport clocks. Vector clocks, a descendent of logical clocks, are one of the main building blocks of today’s distributed systems. They provide means for event ordering and synchronization which are prerequisites for modern NoSQL databases like Amazon DynamoDB. You can find a modern treatment about the topic from Martin Fowler.\nThe Emperor’s Old Clothes by C.A.R Hoare 1980\nLink to paper\nIn Hoare’s Turing lecture, he shares his experiences of designing and implementing programming languages. He muses about his first Algol 60 compiler which was a great success. But his second project failed miserably (maybe because of the second system effect?). It was never delivered, even after years of delay. Failure was caused by well-known product management issues: “lack of software knowledge outside of the programming group, interference from higher managers who imposed decisions,… overoptimism in the face of pressure from customers and the Sales Department”. Eventually the project was reestablished and saved by implementing agile principles like early customer feedback and incremental builds - in the sixties 😂 :\n We assigned to each group of customers a small team of programmers and told the team leader to visit the customers and find out what they wanted; to select the easiest request to fulfil…\n At last, Hoare speaks about his frustrating experience with programming languages committees and the never ending story of feature bloat and negligence of simplicity which leads us to his most famous quote:\n I conclude that there are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so complicated that there are no obvious deficiencies.\n I find it fascinating that his insights about building compilers are not only apparent today but also apply to software product development in general.\nReflections on Trusting Trust by Ken Thomson 1984\nLink to paper\nIn his Turing Lecture Ken Thomson talks about trust:\n You can’t trust code that you did not totally create yourself. (Especially code from companies that employ people like me (Ken Thomson).\n You can’t trust code, this applies especially to software libraries and tools like compilers. In three stages he describes how to inject a Trojan Horse into a compiler without leaving any traces in the source code. This is possible due to re-compiling the compiler and removing the offensive code but the binary is still infected and will inject the offensive code for new compilations. It is hard to grasp but once you have it, it is mind-bending.\nCasually, Ken shows a beautiful Quine, a program that prints its own source code. Have you ever written one? Try it out without looking to solutions - it’s a enlightening experience.\nA Note on Distributed Computing by Jim Waldo, Geoff Wyant, Ann Wollrath, Sam Kendall 1994\nLink to paper\nAbstractions are not for free, often they are leaky, inappropriate or just do more harm than good. This paper gives great insights why you should not treat distributed computing as local computing. Hiding distributed computing under local interfaces is a bad idea. Many technologies failed, trying exactly that - remember SOAP Web Services, Corba, Java EJBs and Java RMI.\nConclusion: one cannot hide the inherent issues of distributed systems, namely latency, concurrency, partial failure etc. behind an abstraction. Developers must always have those in mind and use appropriate techniques in order to build robust and resilient systems. It’s good to see that old fashioned technologies like Corba or Java RMI are fading away and that REST and gRPC via HTTP gained ascendancy.\nA Plea for Lean Software by Niklaus Wirth 1995\nLink to paper\nWirth elaborates about embracing simplicity and fighting complexity, both traits often forgotten by today’s developers and customers. He makes a clear differentiation between inherent complexity and self-inflicted complexity. The later is the main reason for bulky software.\nHis insights about iterative software development, modularization and the decomposition of complex systems are delightful. Especially because those insights transition so well into the modern world with microservices.\nHe proves his points with the Oberon OS, a complete system written by him and his colleague in less then three years. Compare this to IBM OS/360, a project with five thousand man-years budget but infected with self-inflicted complexity and feature bloat. Both projects had a “similar” scope, namely an OS with additional tools like compiler, editor etc.\nIt is one of the best paper’s ever written and makes you a better programmer, simply because it changes your way of approaching big software projects and makes you honor simplicity more than ever.\nWirth’s paper is so full of gems, a selection of quotes (all before the agile revolution):\n Truly good solutions emerge, after iterative improvements or after redesigns that explicit new insights, and the most rewarding iterations are those that result in programming simplifications.\n  The belief that complex systems require armies of designers and programmers is wrong. A system that is not understood in its entirety, or at least to a significant degree of detail by a single individual, should probably not be built.\n  Communication problems grow as the size of the design team grows. Whether they are obvious or not, when communication problems predominate, the team and the project are both in deep trouble.\n  To gain experience, there is no substitute for one’s own programming effort.\n Introduction to Functional Programming by Richard Bird, Philip Wadler 1998\nLink to book\nAlongside Fred Brooks Mythical Man-Month, this is the second book on the list and it is the best introduction to functional programming, period. In a way, it complements SICP, another classic and the best introduction to programming in general.\nThe book touches functional core concepts like immutable and lazy data structures, pure functions, function composition and high-order functions like map, filter, fold. After reading the book, you are well prepared for solving real world problems in a functional way. With these new tools in your toolbox, you will be better programmer and see the world differently. For example, avoiding state and side-effects, will make your code much more readable, more composable, better testable and easier maintainable.\nOut Of The Tar Pit by Ben Moseley, Peter Marks 2006\nLink to paper\nThis paper is a great elaboration about complexity, its causes and how to manage it.\nLike Wirth, the authors distinguish between two types of complexity: essential complexity and accidental complexity. The latter is the main reason why systems are much more complex than necessary. Further they expose state as another major cause for complexity, but also code volume and the negligence of simplicity are main drivers.\nRings a bell? Today avoiding state is tantamount in Computer Science to good, simple and scalable system design. Thinking of functional programming, stateless microservices and HTTP as a stateless protocol.\nOn Designing and Deploying Internet-Scale Services by James Hamilton 2007\nLink to paper\nToday, distributed systems are everywhere. With the raise of ever-growing systems and new tools like Kubernetes, Containers and Microservices, new best practices were needed. This paper is whirlwind tour about best practices to build robust distributed systems in an operating-friendly way.\nThe paper describes keystones like redundancy, fault tolerance, build for failure, avoid single point of failures, geo-distribution, firedrills, fail fast and many more. Without knowing it, he basically describes the contemporary DevOps mindset (and his observations gives us the reason why it makes sense):\n The trend we’ve seen when looking across many services is that low-cost administration correlates highly with how closely the development, test and operations teams work together.\n  If development is frequently called in the middle of the night, automation is the likely outcome. If operations is frequently called, the usual reaction is to grow the operations team.\n I like his tendency to “testing in production” with permanent firedrills and his meticulous attitude leaving nothing to chance:\n The general rule is that nothing works if it isn’t tested frequently.\n It is a great read, especially, if you consider to build “internet-scale” systems. You find most of the advice in other distributed system books but the paper provides them in a condensed and terse way.\nMore Interested in more? You can find a great and free collection of literature at github/papers- we-love.\n","wordCount":"2283","inLanguage":"en","datePublished":"2021-09-10T10:04:01+01:00","dateModified":"2021-09-10T10:04:01+01:00","author":{"@type":"Person","name":"Daniel Gerlach"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://gerlacdt.github.io/posts/classic-papers/"},"publisher":{"@type":"Organization","name":"Daniel's programming rants","logo":{"@type":"ImageObject","url":"https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://gerlacdt.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://gerlacdt.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://gerlacdt.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://gerlacdt.github.io/about title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://gerlacdt.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://gerlacdt.github.io/posts/>Posts</a></div><h1 class=post-title>Reading List for the mindful Software Engineer</h1><div class=post-meta><span title="2021-09-10 10:04:01 +0100 +0100">September 10, 2021</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Daniel Gerlach</div></header><div class=post-content><p>Abstractions are essential in order to build complex systems and keep complexity
under control. Especially in software development we rely on many abstractions
to make our life easier. Although good abstractions do not &ldquo;leak&rdquo;, it&rsquo;s always
helpful to understand the background and the details behind them.</p><p>The following list (in chronological order) of classic computer science papers
will give you insights of inventions of the last decades which are considered
nowadays common sense. But back then, even the most basic concepts needed to be
invented or discovered. I find it fascinating how much you can learn from the
discovery of such breakthroughs and I hope you can learn from them as much as I
did. Further it is quite satisfactory when one is able to connect the dots from
the past to the present. Knowing the history prevent you from reinventing the
wheel and from making same failures over and over again:</p><blockquote><p>Those that fail to learn from history are doomed to repeat it.</p></blockquote><p>by Winston Churchill</p><h3 id=span-stylecolor-bluerecursive-functions-of-symbolic-expressions-and-their-computations-by-machine-part-ispan><span style=color:blue>Recursive Functions of Symbolic Expressions and Their Computations by Machine, Part I</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor-bluerecursive-functions-of-symbolic-expressions-and-their-computations-by-machine-part-ispan>#</a></h3><p>by John McCarthy 1960</p><p><a href=http://www-formal.stanford.edu/jmc/recursive.pdf>Link to paper</a></p><p>This paper is special in it&rsquo;s own ways and is widely considered as a seminal
work of computer science.</p><p>John McCarthy defines the complete LISP programming language in roughly 30
pages. The design of Lisp with <strong>S-expressions</strong> is ingenious because it&rsquo;s so
simple. 1960 most of the programming language concepts, which we consider basic
today, needed to be defined. McCarthy does this on the go. He introduces
<strong>conditional expressions</strong> like <code>if-then-else</code>. Those are needed for
<strong>recursive functions</strong> in order to formulate the recursion termination
condition. Casually he also introduces the first <strong>garbage-collection</strong>
algorithm with a <code>free-storage-list</code>. All in one paper, groundbreaking!</p><p>Unfortunately the paper is hard to &ldquo;digest&rdquo; due to its age. A contemporary and
more comprehensible essay was written by Paul Graham,
<a href=http://www.paulgraham.com/rootsoflisp.html>The Roots of Lisp</a>. Graham picks up
McCarthy&rsquo;s paper and brings it in a more readable form.</p><h3 id=span-stylecolor-blueon-the-criteria-to-be-used-in-decomposing-systems-into-modules-span><span style=color:blue>On the Criteria To Be Used in Decomposing Systems into Modules </span><a hidden class=anchor aria-hidden=true href=#span-stylecolor-blueon-the-criteria-to-be-used-in-decomposing-systems-into-modules-span>#</a></h3><p>by David Parnas 1972</p><p><a href=https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf>Link to paper</a></p><p>Today, we know modularization is a keystone for building large software systems.
Independent and autonomous teams are critical. To achieve autonomy and smooth
collaboration, modules must hide their internal implementation, i.e. they should
only expose the least information which is absolutely necessary. The concept
advocated by Parnas is <strong>information hiding</strong>. It is crucial to <em>encapsulate</em>
the module&rsquo;s internals, so consumers do not have to deal with the module&rsquo;s
internal complexity. Parnas summarizes:</p><blockquote><p>The benefits expected of modular programming are: (1) managerial-development
time should be shortened because separate groups would work on each module
with little need for communication: (2) product flexibility - it should be
possible to make drastic changes to one module without a need to change
others; (3) comprehensibility - it should be possible to study the system one
module at a time. The whole system can therefore be better designed because it
is better understood.</p></blockquote><p>The principle of information hiding enables us to replace an existing
implementation but to keep the exposed interface. Hence existing consumers
remain untouched. Further modules can be reused and provide their functionality
safely. Basically Parnas paved the way for <strong>APIs</strong> which are one of the most
influential and powerful concepts of software engineering. APIs act as contracts
between consumer and producer. This is true in the small scope for software
libraries but also in a large scope for REST-APIs, gRPC and the like.
Modularization is a precondition for <strong>Microservices</strong> whose functionality is
hidden between a well-defined and documented API. Even the Unix Philosophy is a
&ldquo;just&rdquo; a description for a good module:</p><ul><li>Do one thing well</li><li>Write programs that work together</li><li>Write programs to handle text streams, because that is a <em>universal
interface</em>.</li></ul><p>Historical fact: In the seventies information hiding was controversial. Even the
most renowned IT people like Fred Brooks who managed the development of IBM&rsquo;s
System/360 with thousands of people and a budget of 5 billion dollars did not
believe in it. Years later Brooks admitted (after bitter learnings):</p><blockquote><p>David Parnas Was Right, and I Was Wrong About Information Hiding.</p></blockquote><h3 id=span-stylecolor-bluethe-mythical-man-month-essays-on-software-engineeringspan><span style=color:blue>The Mythical Man-Month: Essays on Software Engineering</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor-bluethe-mythical-man-month-essays-on-software-engineeringspan>#</a></h3><p>by Fred Brooks 1975</p><p><a href=https://www.oreilly.com/library/view/mythical-man-month-the/0201835959/>Link to book</a></p><p>Fred Brooks &ldquo;Essays on Software Engineering&rdquo; are from the seventies but many of
his insights still hold up today. 50 years are an eternity in the IT field and
it speaks for the quality of this seminal book.</p><p>In his essay <em>The Mythical Man-Month</em>, he directly addresses software project
management fallacies and bad estimations. Developers are not line workers but
creative problem solvers - increasing their numbers will not positively impact
the project&rsquo;s progress.</p><blockquote><p>Adding manpower to a late software project makes it later.</p></blockquote><blockquote><p>Nine women can&rsquo;t make a baby in one month</p></blockquote><p>Many other terms are coined in his essays. He muses that there is <em>No Silver
Bullet</em>, i.e. no new technology or process that will improve productivity by an
order of magnitude. He also addresses the tendency towards <strong>over-engineering</strong>
in <em>the Second System effect</em> and warns about its consequences.</p><blockquote><p>The second system is most dangerous system a man ever designs &mldr; The general
tendency is to over-design the second system, using all ideas and frills that
were cautiously sidetracked on the first one.</p></blockquote><p>Further, he advocates for small, independent teams. <em>The surgical team</em>, is a
team with 5-10 people and cross-functional skills. Sounds familiar Agile
community?</p><h3 id=span-stylecolor-bluetime-clocks-and-the-ordering-of-events-in-a-distributed-systemspan><span style=color:blue>Time, Clocks, and the Ordering of Events in a Distributed System</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor-bluetime-clocks-and-the-ordering-of-events-in-a-distributed-systemspan>#</a></h3><p>by Leslie Lamport 1978</p><p><a href=https://lamport.azurewebsites.net/pubs/time-clocks.pdf>Link to paper</a></p><p>The seminal paper about <strong>logical clocks</strong> or <em>Lamport clocks</em>. <em>Vector clocks</em>,
a descendent of logical clocks, are one of the main building blocks of today&rsquo;s
distributed systems. They provide means for <em>event ordering and synchronization</em>
which are prerequisites for modern NoSQL databases like
<a href=https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf>Amazon DynamoDB</a>.
You can find a modern treatment about the topic from
<a href=https://martinfowler.com/articles/patterns-of-distributed-systems/lamport-clock.html>Martin Fowler</a>.</p><h3 id=span-stylecolor-bluethe-emperors-old-clothesspan><span style=color:blue>The Emperor&rsquo;s Old Clothes</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor-bluethe-emperors-old-clothesspan>#</a></h3><p>by C.A.R Hoare 1980</p><p><a href=https://dl.acm.org/doi/pdf/10.1145/358549.358561>Link to paper</a></p><p>In Hoare&rsquo;s Turing lecture, he shares his experiences of designing and
implementing programming languages. He muses about his first Algol 60 compiler
which was a great success. But his second project failed miserably (maybe
because of the <em>second system effect</em>?). It was never delivered, even after
years of delay. Failure was caused by well-known product management issues:
&ldquo;lack of software knowledge outside of the programming group, interference from
higher managers who imposed decisions,&mldr; overoptimism in the face of pressure
from customers and the Sales Department&rdquo;. Eventually the project was
reestablished and saved by implementing agile principles like <em>early customer
feedback</em> and <em>incremental builds</em> - in the sixties 😂 :</p><blockquote><p>We assigned to each group of customers a small team of programmers and told
the team leader to visit the customers and find out what they wanted; to
select the easiest request to fulfil&mldr;</p></blockquote><p>At last, Hoare speaks about his frustrating experience with programming
languages committees and the never ending story of feature bloat and negligence
of simplicity which leads us to his most famous quote:</p><blockquote><p>I conclude that there are two ways of constructing a software design: One way
is to make it so simple that there are obviously no deficiencies and the other
way is to make it so complicated that there are no obvious deficiencies.</p></blockquote><p>I find it fascinating that his insights about building compilers are not only
apparent today but also apply to software product development in general.</p><h3 id=span-stylecolor-bluereflections-on-trusting-trustspan><span style=color:blue>Reflections on Trusting Trust</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor-bluereflections-on-trusting-trustspan>#</a></h3><p>by Ken Thomson 1984</p><p><a href=https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf>Link to paper</a></p><p>In his Turing Lecture Ken Thomson talks about trust:</p><blockquote><p>You can&rsquo;t trust code that you did not totally create yourself. (Especially
code from companies that employ people like me (Ken Thomson).</p></blockquote><p><em>You can&rsquo;t trust code</em>, this applies especially to software libraries and tools
like compilers. In three stages he describes how to inject a <em>Trojan Horse</em> into
a compiler without leaving any traces in the source code. This is possible due
to re-compiling the compiler and removing the offensive code but the binary is
still infected and will inject the offensive code for new compilations. It is
hard to grasp but once you have it, it is mind-bending.</p><p>Casually, Ken shows a beautiful
<a href=https://en.wikipedia.org/wiki/Quine_(computing)>Quine</a>, a program that
prints its own source code. Have you ever written one? Try it out without
looking to solutions - it&rsquo;s a enlightening experience.</p><h3 id=span-stylecolor-bluea-note-on-distributed-computingspan><span style=color:blue>A Note on Distributed Computing</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor-bluea-note-on-distributed-computingspan>#</a></h3><p>by Jim Waldo, Geoff Wyant, Ann Wollrath, Sam Kendall 1994</p><p><a href=https://scholar.harvard.edu/files/waldo/files/waldo-94.pdf>Link to paper</a></p><p>Abstractions are not for free, often they are leaky, inappropriate or just do
more harm than good. This paper gives great insights why you should not treat
distributed computing as local computing. Hiding distributed computing under
local interfaces is a bad idea. Many technologies failed, trying exactly that -
remember SOAP Web Services, Corba, Java EJBs and Java RMI.</p><p>Conclusion: one cannot hide the inherent issues of distributed systems, namely
<em>latency, concurrency, partial failure</em> etc. behind an abstraction. Developers
must always have those in mind and use appropriate techniques in order to build
robust and resilient systems. It&rsquo;s good to see that old fashioned technologies
like Corba or Java RMI are fading away and that
<a href=https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design#what-is-rest>REST</a>
and <a href=https://grpc.io/>gRPC</a> via HTTP gained ascendancy.</p><h3 id=span-stylecolor-bluea-plea-for-lean-softwarespan><span style=color:blue>A Plea for Lean Software</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor-bluea-plea-for-lean-softwarespan>#</a></h3><p>by Niklaus Wirth 1995</p><p><a href=https://cr.yp.to/bib/1995/wirth.pdf>Link to paper</a></p><p>Wirth elaborates about embracing <strong>simplicity</strong> and <strong>fighting complexity</strong>,
both traits often forgotten by today&rsquo;s developers and customers. He makes a
clear differentiation between <em>inherent</em> complexity and <em>self-inflicted</em>
complexity. The later is the main reason for bulky software.</p><p>His insights about iterative software development, modularization and the
decomposition of complex systems are delightful. Especially because those
insights transition so well into the modern world with microservices.</p><p>He proves his points with the
<a href=https://en.wikipedia.org/wiki/Oberon_(operating_system)>Oberon OS</a>, a
complete system written by him and his colleague in less then three years.
Compare this to <a href=https://en.wikipedia.org/wiki/IBM_System/360>IBM OS/360</a>, a
project with five thousand man-years budget but infected with self-inflicted
complexity and feature bloat. Both projects had a &ldquo;similar&rdquo; scope, namely an OS
with additional tools like compiler, editor etc.</p><p>It is one of the best paper&rsquo;s ever written and makes you a better programmer,
simply because it changes your way of approaching big software projects and
makes you honor simplicity more than ever.</p><p>Wirth&rsquo;s paper is so full of gems, a selection of quotes (all before the agile
revolution):</p><blockquote><p>Truly good solutions emerge, after iterative improvements or after redesigns
that explicit new insights, and the most rewarding iterations are those that
result in programming simplifications.</p></blockquote><blockquote><p>The belief that complex systems require armies of designers and programmers is
wrong. A system that is not understood in its entirety, or at least to a
significant degree of detail by a single individual, should probably not be
built.</p></blockquote><blockquote><p>Communication problems grow as the size of the design team grows. Whether they
are obvious or not, when communication problems predominate, the team and the
project are both in deep trouble.</p></blockquote><blockquote><p>To gain experience, there is no substitute for one&rsquo;s own programming effort.</p></blockquote><h3 id=span-stylecolor-blueintroduction-to-functional-programmingspan><span style=color:blue>Introduction to Functional Programming</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor-blueintroduction-to-functional-programmingspan>#</a></h3><p>by Richard Bird, Philip Wadler 1998</p><p><a href="https://docs.google.com/viewer?a=v&pid=sites&srcid=ZGVmYXVsdGRvbWFpbnx0aGVhbnVqbWVodGF8Z3g6NzJiOTQ3YTVhODNlY2YyNg">Link to book</a></p><p>Alongside Fred Brooks <em>Mythical Man-Month</em>, this is the second book on the list
and it is the best introduction to functional programming, period. In a way, it
complements
<a href=https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html>SICP</a>,
another classic and the best introduction to programming in general.</p><p>The book touches functional core concepts like immutable and lazy data
structures, pure functions, function composition and high-order functions like
<em>map, filter, fold</em>. After reading the book, you are well prepared for solving
real world problems in a functional way. With these new tools in your toolbox,
you will be better programmer and see the world differently. For example,
avoiding state and side-effects, will make your code much more readable, more
composable, better testable and easier maintainable.</p><h3 id=span-stylecolor-blueout-of-the-tar-pitspan><span style=color:blue>Out Of The Tar Pit</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor-blueout-of-the-tar-pitspan>#</a></h3><p>by Ben Moseley, Peter Marks 2006</p><p><a href=http://curtclifton.net/papers/MoseleyMarks06a.pdf>Link to paper</a></p><p>This paper is a great elaboration about complexity, its causes and how to manage
it.</p><p>Like Wirth, the authors distinguish between two types of complexity: <em>essential
complexity</em> and <em>accidental complexity</em>. The latter is the main reason why
systems are much more complex than necessary. Further they expose <strong>state</strong> as
another major cause for complexity, but also code volume and the negligence of
simplicity are main drivers.</p><p>Rings a bell? Today <em>avoiding state</em> is tantamount in Computer Science to good,
simple and scalable system design. Thinking of functional programming, stateless
microservices and HTTP as a stateless protocol.</p><h3 id=span-stylecolor-blueon-designing-and-deploying-internet-scale-servicesspan><span style=color:blue>On Designing and Deploying Internet-Scale Services</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor-blueon-designing-and-deploying-internet-scale-servicesspan>#</a></h3><p>by James Hamilton 2007</p><p><a href=https://www.usenix.org/legacy/event/lisa07/tech/full_papers/hamilton/hamilton.pdf>Link to paper</a></p><p>Today, distributed systems are everywhere. With the raise of ever-growing
systems and new tools like Kubernetes, Containers and Microservices, new best
practices were needed. This paper is whirlwind tour about best practices to
build robust distributed systems in an <em>operating-friendly</em> way.</p><p>The paper describes keystones like <em>redundancy, fault tolerance, build for
failure, avoid single point of failures, geo-distribution, firedrills, fail
fast</em> and many more. Without knowing it, he basically describes the contemporary
<strong>DevOps</strong> mindset (and his observations gives us the reason why it makes
sense):</p><blockquote><p>The trend we&rsquo;ve seen when looking across many services is that low-cost
administration correlates highly with how closely the development, test and
operations teams work together.</p></blockquote><blockquote><p>If development is frequently called in the middle of the night, automation is
the likely outcome. If operations is frequently called, the usual reaction is
to grow the operations team.</p></blockquote><p>I like his tendency to &ldquo;testing in production&rdquo; with permanent firedrills and his
meticulous attitude leaving nothing to chance:</p><blockquote><p>The general rule is that nothing works if it isn&rsquo;t tested <strong>frequently</strong>.</p></blockquote><p>It is a great read, especially, if you consider to build &ldquo;internet-scale&rdquo;
systems. You find most of the advice in other distributed system books but the
paper provides them in a condensed and terse way.</p><h5 id=more>More<a hidden class=anchor aria-hidden=true href=#more>#</a></h5><p>Interested in more? You can find a great and free collection of literature at
<em><a href=https://github.com/papers-we-love/papers-we-love>github/papers- we-love</a></em>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://gerlacdt.github.io/tags/programming/>programming</a></li></ul><nav class=paginav><a class=prev href=https://gerlacdt.github.io/posts/nonproductive-programmer/><span class=title>« Prev Page</span><br><span>The Non-Productive Programmer (NPP)</span></a>
<a class=next href=https://gerlacdt.github.io/posts/it-test-db-sidecar-jenkins/><span class=title>Next Page »</span><br><span>Database Integration Tests with Docker Sidecar in Jenkins</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Reading List for the mindful Software Engineer on twitter" href="https://twitter.com/intent/tweet/?text=Reading%20List%20for%20the%20mindful%20Software%20Engineer&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fclassic-papers%2f&hashtags=programming"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Reading List for the mindful Software Engineer on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fclassic-papers%2f&title=Reading%20List%20for%20the%20mindful%20Software%20Engineer&summary=Reading%20List%20for%20the%20mindful%20Software%20Engineer&source=https%3a%2f%2fgerlacdt.github.io%2fposts%2fclassic-papers%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Reading List for the mindful Software Engineer on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fclassic-papers%2f&title=Reading%20List%20for%20the%20mindful%20Software%20Engineer"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Reading List for the mindful Software Engineer on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fgerlacdt.github.io%2fposts%2fclassic-papers%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Reading List for the mindful Software Engineer on whatsapp" href="https://api.whatsapp.com/send?text=Reading%20List%20for%20the%20mindful%20Software%20Engineer%20-%20https%3a%2f%2fgerlacdt.github.io%2fposts%2fclassic-papers%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Reading List for the mindful Software Engineer on telegram" href="https://telegram.me/share/url?text=Reading%20List%20for%20the%20mindful%20Software%20Engineer&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fclassic-papers%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://gerlacdt.github.io/>Daniel's programming rants</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>