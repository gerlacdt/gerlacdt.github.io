<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Things to consider with microservices | Daniel's programming rants</title><meta name=keywords content="programming,microservices"><meta name=description content="Introduction Some years ago i was involved in migrating a big IBM Websphere monolith into a microservice landscape. We had a lot of problems with the monolith. Our development speed slowed down. We had many merge conflicts because of too many dependencies in the codebase. We outgrew the monolithic design and decided to introduce microservices. We extracted different domains like payment, booking, user and search. The teams were restructured into two-pizza teams."><meta name=author content="Daniel Gerlach"><link rel=canonical href=https://gerlacdt.github.io/posts/microservices/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4BE9J0ZRDL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4BE9J0ZRDL",{anonymize_ip:!1})}</script><meta property="og:title" content="Things to consider with microservices"><meta property="og:description" content="Introduction Some years ago i was involved in migrating a big IBM Websphere monolith into a microservice landscape. We had a lot of problems with the monolith. Our development speed slowed down. We had many merge conflicts because of too many dependencies in the codebase. We outgrew the monolithic design and decided to introduce microservices. We extracted different domains like payment, booking, user and search. The teams were restructured into two-pizza teams."><meta property="og:type" content="article"><meta property="og:url" content="https://gerlacdt.github.io/posts/microservices/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-03-30T09:53:54+01:00"><meta property="article:modified_time" content="2019-03-30T09:53:54+01:00"><meta property="og:site_name" content="Daniel's programming rants"><meta name=twitter:card content="summary"><meta name=twitter:title content="Things to consider with microservices"><meta name=twitter:description content="Introduction Some years ago i was involved in migrating a big IBM Websphere monolith into a microservice landscape. We had a lot of problems with the monolith. Our development speed slowed down. We had many merge conflicts because of too many dependencies in the codebase. We outgrew the monolithic design and decided to introduce microservices. We extracted different domains like payment, booking, user and search. The teams were restructured into two-pizza teams."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://gerlacdt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Things to consider with microservices","item":"https://gerlacdt.github.io/posts/microservices/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Things to consider with microservices","name":"Things to consider with microservices","description":"Introduction Some years ago i was involved in migrating a big IBM Websphere monolith into a microservice landscape. We had a lot of problems with the monolith. Our development speed slowed down. We had many merge conflicts because of too many dependencies in the codebase. We outgrew the monolithic design and decided to introduce microservices. We extracted different domains like payment, booking, user and search. The teams were restructured into two-pizza teams.","keywords":["programming","microservices"],"articleBody":"Introduction Some years ago i was involved in migrating a big IBM Websphere monolith into a microservice landscape. We had a lot of problems with the monolith. Our development speed slowed down. We had many merge conflicts because of too many dependencies in the codebase. We outgrew the monolithic design and decided to introduce microservices. We extracted different domains like payment, booking, user and search. The teams were restructured into two-pizza teams.\nThe whole migration was very structured and well planned. We migrated incrementally with the strangler pattern. As long we were ~20 developers in 5 different teams, everything was fine. Teams worked independently in their domain. They could scale, deploy independently and followed their own release cycles.\nBut microservices bring new technical challenges. Maybe you know the saying:\n Microservices solve organizational problems.\nMicroservices cause technical problems.\n Peter Bourgon\nDevelopers tend to ignore, forget or just simply do not know about these challenges. They are overwhelmed by the new opportunities in the shiny microservice world. In the following i want to present my experience what we underestimated or forgot in our microservice-migration.\nAvoid a heterogeneous IT-landscape Microservices give you a lot of freedom which technology to choose like programming language, database or web-framework. This is both boon and bane. On the one side every team can choose the technology which fits best, on the other side developers are adventurous and try out new fancy programming languages and other bleeding edge technology. And soon you have a dozen different tech stacks to support. Some teams build their own tech-knowledge silos. And don’t get me wrong here, it is totally fine if a team has its domain-knowledge silo, but it is not fine if the team is the only one in the company who uses a fancy programming language. At Google, they have thousands of engineers and they try to stick to only 4 languages in the backend. The supported languages are C++, Java, Python and Go, see Software Engineering at Google, Fergus Henderson. If a backend team wants to start with another language they need to argument very hard why they cannot fulfil their job with the company-wide supported languages. There is a clear decision-process in place how to introduce a new technology. This restricts the developers from using the newest bleeding-edge technology. Another advantage is that one can focus on business problems and avoid discussions about tech explorations etc. Your internal libraries need to be written in and supported for few languages. Developers will also have an easy time when they want to switch teams. Team rotation is encouraged, facilitates knowledge-transfer and pushes developers out of their comfort zone which makes them more valuable.\nA technology radar serves as an overview for the supported tools, programming languages and platforms. A radar helps to keep track of all technology used in your company.\nHave a good Monitoring/Tracing/Logging in place We suffered sometime from logging problems because our ElasticSearch cluster was overloaded or some indices had conflicts. Logging is hard. Make sure you have clear logging-guildlines. Do not log too much, at best you have silent services, i.e. only log if a manual intervention is needed in case of an error. Logging is fine for debugging and error tracking in the development stage but it should not be overused in production. Be careful if your monitoring and alarming is based on logging. If your log-cluster is flooded, your monitoring will not work either!\nHave strict rules for monitoring. No service should go into production without monitoring. With microservices you need transparency in order to do failure analysis or get notified if something is wrong. At least monitor the four golden signals:\n  Latency. How high is the response time? Make sure you distinguish failed requests from successful requests. Failed requests can be fast and screw up your metrics.\n  Traffic. How many Requests per second (RPS) do we serve?\n  Errors. How high is the error rate?  Number of error responses / Number of successful responses\n  Saturation. How full is your service? CPU utilisation, memory consumption.\n  Don’t forget the 8 fallacies of distributed computing Fallacies of distributed computing by Peter Deutsch\n  The network is reliable.\nYour HTTP-calls will fail from time to time. So make sure you have some retry-mechanism in place. But do not retry naively! E.g. retries make no sense if the http response code is 400 BAD_REQUEST, no matter how often you try the request will never be successful. Neither you should do retries on POST requests, HTTP POST requests are by definition not idempotent and you could accidentally create a lot of resources like orders or trigger payments. Your customers will not be happy.\nYou should also limit your retries, do not retry indefinitely, otherwise you can cause overload on other services, see cascading failures.\nDo not forget to protect your services with timeouts. Missing timeouts make I/O calls wait too long and if they pile up they consume all your memory or other resources like a thread pool. In the worst case you service will be killed by your docker scheduler because the memory limit is exceeded.\nFor very high-load services you should consider load shedding or graceful degradation in order to protect these service from going down.\n  Latency is zero.\nNetwork can be slow. You should clearly separate internal function calls from network calls. E.g. do not use network calls in loops. Better fetch everything with one network call.\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14  // bad practice! Doing multiple network calls function getUsers(userIds) {  const users = [];  for (id of userIds) {  const user = http.fetchSingleUser(id);  users.push(user);  }  return users; }  // good, only one network call function getUsers(userIds) {  return http.fetchUsers(userIds); }    Bandwidth is infinite.\nUse your bandwidth sparingly. E.g logging every http request and response is definitely too much. Do not use sql-statements like this: SELECT * from table, always select only required columns.\n  The network is secure.\n  Topology doesn’t change.\nEspecially with self-healing services and docker random port usage, IP-addresses and ports change often. Do not use static IP-addresses or static ports. Use sophisticated service-discovery mechanisms. Many Docker-Scheduler provide them out-of-the-box like Kubernetes or Hashicorp’s Nomad. With AWS ECS you can use an AWS Application Load Balancer (ALB) for service discovery.\n  There is one administrator.\nDistributed systems are complex. Do not expect that there is one person who knows it all. For bug analysis you need multiple people or teams.\n  Transport cost is zero.\nNetwork calls are expensive. You need to establish a connection, you need to serialize and deserialize the message body which cost CPU. The less you send the better. If you notice that you services are chatty, consider restructuring the domain boundaries. Most probably your domains do overlap or have multiple responsibilities.\n  The network is homogeneous\nIt’s not. Before docker, almost all applications ran on customized, “snowflaky” servers configured via non-reproducible ssh-session. With Kubernetes or AWS ECS you can have clusters with thousands of servers which are configured exactly the same. One single DevOps guy can operate thousands of servers! Therefore you should agree on a common cluster management tool with as few clusters as possible. Only then, you gain the real advantages of Docker. Further agree on a single data transfer format like JSON or Protocol Buffers with gRPC. Strive for as much homogeneity as possible to reduce operation and maintenance costs. In my opinion the homogeneity provided by Docker is its biggest advantage.\n  Other things to consider   Keep your domain boundaries clear and separated. Teams should always be able to deploy independently and without consulting other teams. You ever experienced a deployment where 3 or 4 services were involved and had to be deployed synchronously because of incompatibilities of API-versions or dependency on the same database. Congratulations you built a distributed monolith.\n  Have a good CI/CD pipeline with automatic tests and deployments. Make sure all teams use the same deployment and glue scripts. Use one cluster (Kubernetes, AWS ECS, Hashicorp Nomad) for the whole company (as long as you do not exceed hundreds of servers). This will keep the maintenance effort low.\n  If you have reusable modules/libraries, make sure you have transitive CI-builds\n  Adhere to good coding cloud-native practices, see 12-factor-app and Site Reliability Engineering\n  Conclusion Microservices are hard. Do not forget this. In the web you hear mainly about the big success-stories like Google, Amazon and the like. But for the most of us there are serious disadvantages which are normally not mentioned. And do not get me wrong, microservices are great. It was definitely the way to go for us. Today we are more than 100 developers and it gives me the creeps when i imagine that all of them would work on single monolithic git-repository. It is a long and hard way to a productive microservice landscape but definitively worth it. Just do not underestimate monitoring, automation and the fallacies of distributed systems!\n","wordCount":"1485","inLanguage":"en","datePublished":"2019-03-30T09:53:54+01:00","dateModified":"2019-03-30T09:53:54+01:00","author":{"@type":"Person","name":"Daniel Gerlach"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://gerlacdt.github.io/posts/microservices/"},"publisher":{"@type":"Organization","name":"Daniel's programming rants","logo":{"@type":"ImageObject","url":"https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://gerlacdt.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://gerlacdt.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://gerlacdt.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://gerlacdt.github.io/about title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://gerlacdt.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://gerlacdt.github.io/posts/>Posts</a></div><h1 class=post-title>Things to consider with microservices</h1><div class=post-meta><span title="2019-03-30 09:53:54 +0100 CET">March 30, 2019</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Daniel Gerlach</div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Some years ago i was involved in migrating a big IBM Websphere
monolith into a microservice landscape. We had a lot of problems with
the monolith. Our development speed slowed down. We had many merge
conflicts because of too many dependencies in the codebase. We outgrew
the monolithic design and decided to introduce microservices. We
extracted different domains like payment, booking, user and
search. The teams were restructured into two-pizza teams.</p><p>The whole migration was very structured and well planned. We migrated
incrementally with the <a href=https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler>strangler
pattern</a>.
As long we were ~20 developers in 5 different teams, everything was
fine. Teams worked independently in their domain. They could scale,
deploy independently and followed their own release cycles.</p><p>But microservices bring new technical challenges. Maybe you know the saying:</p><blockquote><p>Microservices solve organizational problems.</p><p>Microservices cause technical problems.</p></blockquote><p><a href="https://speakerdeck.com/peterbourgon/go-plus-microservices-equals-go-kit?slide=15">Peter Bourgon</a></p><p>Developers tend to ignore, forget or just simply do not know about
these challenges. They are overwhelmed by the new opportunities in the
shiny microservice world. In the following i want to present my
experience what we underestimated or forgot in our
microservice-migration.</p><h2 id=avoid-a-heterogeneous-it-landscape>Avoid a heterogeneous IT-landscape<a hidden class=anchor aria-hidden=true href=#avoid-a-heterogeneous-it-landscape>#</a></h2><p>Microservices give you a lot of freedom which technology to choose
like programming language, database or web-framework. This is both
boon and bane. On the one side every team can choose the technology
which fits best, on the other side developers are adventurous and try
out new fancy programming languages and other bleeding edge
technology. And soon you have a dozen different tech stacks to
support. Some teams build their own tech-knowledge silos. And don&rsquo;t
get me wrong here, it is totally fine if a team has its
domain-knowledge silo, but it is not fine if the team is the only one
in the company who uses a fancy programming language. At Google, they
have thousands of engineers and they try to stick to only 4 languages
in the backend. The supported languages are C++, Java, Python and Go,
see <a href=https://arxiv.org/pdf/1702.01715.pdf>Software Engineering at Google, Fergus
Henderson</a>. If a backend team
wants to start with another language they need to argument very hard
why they cannot fulfil their job with the company-wide supported
languages. There is a clear decision-process in place how to introduce
a new technology. This restricts the developers from using the newest
bleeding-edge technology. Another advantage is that one can focus on
business problems and avoid discussions about tech explorations
etc. Your internal libraries need to be written in and supported for
few languages. Developers will also have an easy time when they want
to switch teams. Team rotation is encouraged, facilitates
knowledge-transfer and pushes developers out of their comfort zone
which makes them more valuable.</p><p>A <a href=https://www.thoughtworks.com/de/radar>technology radar</a> serves as
an overview for the supported tools, programming languages and
platforms. A radar helps to keep track of all technology used in your
company.</p><h2 id=have-a-good-monitoringtracinglogging-in-place>Have a good Monitoring/Tracing/Logging in place<a hidden class=anchor aria-hidden=true href=#have-a-good-monitoringtracinglogging-in-place>#</a></h2><p>We suffered sometime from logging problems because our ElasticSearch
cluster was overloaded or some indices had conflicts. Logging is
hard. Make sure you have clear logging-guildlines. Do not log too
much, at best you have <a href=https://peter.bourgon.org/blog/2016/02/07/logging-v-instrumentation.html>silent
services</a>,
i.e. only log if a manual intervention is needed in case of an
error. Logging is fine for debugging and error tracking in the
development stage but it should not be overused in production. Be
careful if your monitoring and alarming is based on logging. If your
log-cluster is flooded, your monitoring will not work either!</p><p>Have strict rules for monitoring. No service should go into production
without monitoring. With microservices you need transparency in order
to do failure analysis or get notified if something is wrong. At least
monitor the <a href=https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/#xref_monitoring_golden-signals>four golden
signals</a>:</p><ol><li><p>Latency. How high is the response time? Make sure you distinguish
failed requests from successful requests. Failed requests can be
fast and screw up your metrics.</p></li><li><p>Traffic. How many Requests per second (RPS) do we serve?</p></li><li><p>Errors. How high is the error rate?</br>Number of error responses / Number of successful responses</p></li><li><p>Saturation. How full is your service? CPU utilisation, memory
consumption.</p></li></ol><h2 id=dont-forget-the-8-fallacies-of-distributed-computing>Don&rsquo;t forget the 8 fallacies of distributed computing<a hidden class=anchor aria-hidden=true href=#dont-forget-the-8-fallacies-of-distributed-computing>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing>Fallacies of distributed computing by Peter
Deutsch</a></p><ol><li><p>The network is reliable.</p><p>Your HTTP-calls will fail from time to time. So make sure you have
some retry-mechanism in place. But do not retry naively!
E.g. retries make no sense if the http response code is 400
BAD_REQUEST, no matter how often you try the request will never be successful.
Neither you should do retries on POST requests, HTTP POST requests
are by definition not idempotent and you could accidentally create a
lot of resources like orders or trigger payments. Your customers will not
be happy.</p><p>You should also limit your retries, do not retry indefinitely,
otherwise you can cause overload on other services, see
<a href=https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/>cascading failures</a>.</p><p>Do not forget to protect your services with timeouts. Missing timeouts
make I/O calls wait too long and if they pile up they consume all
your memory or other resources like a thread pool. In the worst case you service will be killed by your docker scheduler because the memory limit is exceeded.</p><p>For very high-load services you should consider <a href=https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/#xref_cascading-failure_load-shed-graceful-degredation>load shedding or
graceful degradation</a>
in order to protect these service from going down.</p></li><li><p>Latency is zero.</p><p>Network can be slow. You should clearly separate internal function
calls from network calls. E.g. do not use network calls in
loops. Better fetch everything with one network call.</p></li></ol><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// bad practice! Doing multiple network calls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getUsers</span>(<span style=color:#a6e22e>userIds</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>users</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>userIds</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>fetchSingleUser</span>(<span style=color:#a6e22e>id</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>users</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>user</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>users</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// good, only one network call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getUsers</span>(<span style=color:#a6e22e>userIds</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>fetchUsers</span>(<span style=color:#a6e22e>userIds</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><ol start=3><li><p>Bandwidth is infinite.</p><p>Use your bandwidth sparingly. E.g logging every http request and
response is definitely too much. Do not use sql-statements like this:
<code>SELECT * from table</code>, always select only required columns.</p></li><li><p>The network is secure.</p></li><li><p>Topology doesn&rsquo;t change.</p><p>Especially with self-healing services and docker random port usage,
IP-addresses and ports change often. Do not use static IP-addresses
or static ports. Use sophisticated service-discovery
mechanisms. Many Docker-Scheduler provide them out-of-the-box like
<a href=https://kubernetes.io/>Kubernetes</a> or <a href=https://www.nomadproject.io/>Hashicorp&rsquo;s
Nomad</a>. With <a href=https://aws.amazon.com/ecs/>AWS
ECS</a> you can use an <a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html>AWS Application
Load Balancer</a> (ALB) for service discovery.</p></li><li><p>There is one administrator.</p><p>Distributed systems are complex. Do not expect that there is
one person who knows it all. For bug analysis you need multiple
people or teams.</p></li><li><p>Transport cost is zero.</p><p>Network calls are expensive. You need to establish a connection,
you need to serialize and deserialize the message body which cost
CPU. The less you send the better. If you notice that you
services are chatty, consider restructuring the domain
boundaries. Most probably your domains do overlap or have multiple
responsibilities.</p></li><li><p>The network is homogeneous</p><p>It&rsquo;s not. Before docker, almost all applications ran on customized,
&ldquo;snowflaky&rdquo; servers configured via non-reproducible
ssh-session. With Kubernetes or AWS ECS you can have clusters with
thousands of servers which are configured exactly the same. One
single DevOps guy can operate thousands of servers! Therefore you
should agree on a common cluster management tool with as few
clusters as possible. Only then, you gain the real advantages of
Docker. Further agree on a single data transfer format like
<a href=https://www.json.org/>JSON</a> or <a href=https://developers.google.com/protocol-buffers/>Protocol
Buffers</a> with
<a href=https://grpc.io/>gRPC</a>. Strive for as much homogeneity as
possible to reduce operation and maintenance costs. In my opinion
the homogeneity provided by Docker is its biggest advantage.</p></li></ol><h2 id=other-things-to-consider>Other things to consider<a hidden class=anchor aria-hidden=true href=#other-things-to-consider>#</a></h2><ul><li><p>Keep your domain boundaries clear and separated. Teams should always
be able to deploy independently and without consulting other
teams. You ever experienced a deployment where 3 or 4 services were
involved and had to be deployed synchronously because of
incompatibilities of API-versions or dependency on the same database.
Congratulations you built a distributed monolith.</p></li><li><p>Have a good CI/CD pipeline with automatic tests and deployments.
Make sure all teams use the same deployment and glue scripts. Use
one cluster (Kubernetes, AWS ECS, Hashicorp Nomad) for the whole
company (as long as you do not exceed hundreds of servers). This
will keep the maintenance effort low.</p></li><li><p>If you have reusable modules/libraries, make sure you have
transitive CI-builds</p></li><li><p>Adhere to good coding cloud-native practices, see
<a href=https://12factor.net>12-factor-app</a> and <a href=https://landing.google.com/sre/books/>Site Reliability
Engineering</a></p></li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Microservices are hard. Do not forget this. In the web you hear mainly
about the big success-stories like Google, Amazon and the like. But
for the most of us there are serious disadvantages which are normally
not mentioned. And do not get me wrong, microservices are great. It
was definitely the way to go for us. Today we are more than 100
developers and it gives me the creeps when i imagine that all of them
would work on single monolithic git-repository. It is a long and hard
way to a productive microservice landscape but definitively worth
it. Just do not underestimate monitoring, automation and the fallacies
of distributed systems!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://gerlacdt.github.io/tags/programming/>programming</a></li><li><a href=https://gerlacdt.github.io/tags/microservices/>microservices</a></li></ul><nav class=paginav><a class=prev href=https://gerlacdt.github.io/posts/emacs-test-regexps/><span class=title>« Prev Page</span><br><span>Emacs Test Regexps</span></a>
<a class=next href=https://gerlacdt.github.io/posts/my-presentations/><span class=title>Next Page »</span><br><span>My Presentations</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Things to consider with microservices on twitter" href="https://twitter.com/intent/tweet/?text=Things%20to%20consider%20with%20microservices&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fmicroservices%2f&hashtags=programming%2cmicroservices"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Things to consider with microservices on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fmicroservices%2f&title=Things%20to%20consider%20with%20microservices&summary=Things%20to%20consider%20with%20microservices&source=https%3a%2f%2fgerlacdt.github.io%2fposts%2fmicroservices%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Things to consider with microservices on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fmicroservices%2f&title=Things%20to%20consider%20with%20microservices"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Things to consider with microservices on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fgerlacdt.github.io%2fposts%2fmicroservices%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Things to consider with microservices on whatsapp" href="https://api.whatsapp.com/send?text=Things%20to%20consider%20with%20microservices%20-%20https%3a%2f%2fgerlacdt.github.io%2fposts%2fmicroservices%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Things to consider with microservices on telegram" href="https://telegram.me/share/url?text=Things%20to%20consider%20with%20microservices&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fmicroservices%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://gerlacdt.github.io/>Daniel's programming rants</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>