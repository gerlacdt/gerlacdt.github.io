<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Best Books For The Inquisitive Software Engineer | Daniel's programming rants</title><meta name=keywords content="programming,softwareengineering"><meta name=description content="This article contains a list of my favorite books with a major impact on my Software Engineering career. The books are categorized in:
 Software Engineering Programming Brian Kernighan’s Books Modern Classics Learning Management and Leadership Unix Books From Stevens  Software Engineering A Philosophy of Software Design by John Ousterhout
Link to book
A fabulous book to level up your software design skills as an experienced engineer. The book is full of great advice."><meta name=author content="Daniel Gerlach"><link rel=canonical href=https://gerlacdt.github.io/posts/programming-books/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-138086762-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Best Books For The Inquisitive Software Engineer"><meta property="og:description" content="This article contains a list of my favorite books with a major impact on my Software Engineering career. The books are categorized in:
 Software Engineering Programming Brian Kernighan’s Books Modern Classics Learning Management and Leadership Unix Books From Stevens  Software Engineering A Philosophy of Software Design by John Ousterhout
Link to book
A fabulous book to level up your software design skills as an experienced engineer. The book is full of great advice."><meta property="og:type" content="article"><meta property="og:url" content="https://gerlacdt.github.io/posts/programming-books/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-04T10:00:00+02:00"><meta property="article:modified_time" content="2022-11-04T10:00:00+02:00"><meta property="og:site_name" content="Daniel's programming rants"><meta name=twitter:card content="summary"><meta name=twitter:title content="Best Books For The Inquisitive Software Engineer"><meta name=twitter:description content="This article contains a list of my favorite books with a major impact on my Software Engineering career. The books are categorized in:
 Software Engineering Programming Brian Kernighan’s Books Modern Classics Learning Management and Leadership Unix Books From Stevens  Software Engineering A Philosophy of Software Design by John Ousterhout
Link to book
A fabulous book to level up your software design skills as an experienced engineer. The book is full of great advice."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://gerlacdt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Best Books For The Inquisitive Software Engineer","item":"https://gerlacdt.github.io/posts/programming-books/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Best Books For The Inquisitive Software Engineer","name":"Best Books For The Inquisitive Software Engineer","description":"This article contains a list of my favorite books with a major impact on my Software Engineering career. The books are categorized in:\n Software Engineering Programming Brian Kernighan’s Books Modern Classics Learning Management and Leadership Unix Books From Stevens  Software Engineering A Philosophy of Software Design by John Ousterhout\nLink to book\nA fabulous book to level up your software design skills as an experienced engineer. The book is full of great advice.","keywords":["programming","softwareengineering"],"articleBody":"This article contains a list of my favorite books with a major impact on my Software Engineering career. The books are categorized in:\n Software Engineering Programming Brian Kernighan’s Books Modern Classics Learning Management and Leadership Unix Books From Stevens  Software Engineering A Philosophy of Software Design by John Ousterhout\nLink to book\nA fabulous book to level up your software design skills as an experienced engineer. The book is full of great advice. You often will relate to your own experiences (and mistakes). It mainly speaks about how to manage complexity with information hiding, low coupling and high cohesion.\nHighlights:\n shallow vs deep modules tactical vs strategic programming Design it twice Importance of good naming Importance of good code comments Avoid Classitis Define errors out of existence  The Pragmatic Programmer by Dave Thomas and Andrew Hunt\nLink to book\nThe Pragmatic Programmer is a whirlwind of highly effective programming practices and a great addition to A Philosophy of Software Design. It focuses more on practical programming skills and teaches how to approach programming problems in general. Even after twenty years, it is highly relevant today.\nHighlights:\n DRY principle Orthogonal design Rubber Ducking Broken window theory Programming by Coincidence Design by Contract Importance of Tooling (shell, text manipulation, editor, IDE, version control etc.)  Code Complete by Steve McConnell\nLink to book\nAn all-time classic about all facets of programming. In the 90s and the early 2000s, Code Complete was the undisputed programming bible. If you want to learn about the ins and outs of programming, this book is for you.\nHighlights:\n High-Quality Functions High-Quality Classes High-Quality Software Design Good Comments Code Tunings Testing Debugging Pseudo Programming Process (PPP), an almost forgotten alternative to TDD  Clean Code by Robert C. Martin\nLink to book\nClean Code will teach you good programming techniques and styles. It coined the term clean code and is a great read for junior and medium programmers. Unfortunately, it aged quite heavily and is has it quirks. What bugged me the most are the lengthy and hard to comprehend code examples. My personal pet peeve is the Clean Code prime generator . Compare this with my pragmatic implementation. On top of that, the mantra-like writing style can cause furious discussions at work if teammates treat the book as their “bible”. Nevertheless Clean Code taught generations of programmers and is rightly considered a classic.\nHighlights:\n Naming things Good functions Good Classes Good/Bad Comments TDD flow and Unit Tests SOLID principles (contained in the book but the catchy name was invented later)  Refactoring by Martin Fowler\nLink to book\nMartin Fowler is a giant in modern Software Engineering. He was involved in countless seminal contributions in the last decades. For me Refactoring had the most impact. The biggest part of the book is a catalog of refactoring strategies classified into categories like encapsulation, API, inheritance etc. But the most important thing is: The book teaches how to think as an effective programmer. More so, Refactoring pinpoints a clear way of writing code efficiently, always focusing on keeping code complexity low.\nHighlights:\n Refactoring as a design tool Writing code efficiently and pragmatically  small code changes which are easily reversible If you cannot add a feature conveniently, refactor first If code is never touched, refactoring is probably a waste of time refactoring first, performance tunings later (it’s much easier to tune clean code) “Always leave the code base healthier than when you found it.” “If someone says their code was broken for couple of days while they are refactoring, you can be pretty sure they were not refactoring.”   Teaches the coherence of Refactoring and TDD  refactoring without tests is not refactoring changing tests during refactoring is a sign of bad design or brittle tests   Detect and Eliminate Code Smells  Test-Driven-Development by Kent Beck\nLink to book\nThe best introduction into one of the game-changing programming techniques of the last decades. It is an outstanding guide for TDD. Still, TDD is a big topic and a thoughtless use of TDD could end up in a maintenaince burden. For an outright view, you should consult other resources which consider fallacies like brittle and flaky tests, overuse of mocks and long-running tests.\nHighlights:\n Real Life Unit Test example (Money Class) xUnit Test Framework test patterns  test isolation test first test fixtures learning an API or a framework with tests    Design Patterns by GoF aka Erich Gamma, John Vlissides, Ralph Johnson, Richard Helm\nLink to book\nA seminal textbook from the 90s. Patterns build the foundation for well designed OOP systems. The biggest achievement of design patterns is the facilitated communication between engineers. It is no longer necessary to drone on programming details but sharing the pattern name is enough.\nHighlights:\n OOP design Recurring design patterns explained  Singleton Visitor Adapter Builder Command Facade Iterator Observer    Extreme Programming Explained by Kent Beck\nLink to book\nThe real book about agile. All commercial agile frameworks like Scrum, Kanban and SAFe are based on Extreme Programming (XP). The practices and principles presented here are everlasting and can be applied in any contemporary project.\n XP can exist without Scrum. Scrum cannot exist without XP.\n Highlights:\n Pair Programming Continuous Integration CI/CD Daily Deployment Cross-functional teams Incremental Builds Testing early, often and automated (TDD) Customer Involvement Sustainable Pace  Domain Driven Design by Eric Evans\nLink to book\nA classic from the early 2000s. It coined the term Domain Driven Design (DDD) and is still the best way to structure medium- to large-sized business application. With the rise of microservices, the most influential concepts like Strategic Design, Ubiquitous Language and Bounded Context are even more relevant today. Besides the standard tactical design notions like Entities, Aggregates, Services and Repositories, you can find great refactoring advice too, e.g. Intention-Revealing Interfaces, Side-Effect-Free functions, domain class invariants with explicit constraints etc. Alas, DDD is verbose, luckily a more condensed version with the essential ideas can be found here.\nHighlights:\n Strategic Design  Bounded Context   Ubiquitous language Layered Architecture  Modules Entities, Value Objects, Aggregates Services Repositories Factories   refactorings:  intention-revealing interfaces domain class invariants    The Mythical Man-Month by Fred Brooks\nLink to book\nThe last book in the Software Engineering category but the most influential one. Brooks wrote down his experience of leading the development of IBM’s gigantic OS/360 operating system. The project effort was roughly 5000 man years. The book is full of famous quotes, contains seminal Software Engineering ideas and is clearly a must-read for anyone working in the IT area. After forty years, highly relevant today!\nHighlights:\n Adding manpower to a late software project makes it later. Nine women can’t make a baby in one month. Second System Effect (aka over-engineering) No Silver Bullet Plan to throw one away (aka prototyping) Surgical Team (aka small cross-functional teams)  Programming Structure and Interpretation of Computer Programs (SICP) by Harold Abelson and Gerald Jay Sussman with Julie Sussman\nLink to book\nThe best programming book ever written, period. The book is the best introduction to programming and will teach you all basic concepts a programmer must know. This includes expressions, procedures, recursion, evaluation and lot more. Advanced concepts are covered too, like lazy streams, memoization and concurrency. Exercises at the end of all chapters help you to revise and deepen the acquired knowledge. A highlight is the implementation of some OOP concepts like polymorphism and encapsulation from scratch. Experienced Java or C++ developers will be fascinated how simple it can be!\nNowadays there is also a contemporary Javascript edition, but I myself prefer Scheme.\nHighlights\n Great way to learn programming Learn timeless programming practices that stick with you forever  Pure functions, the assignment statement is introduced at page 220!   Lisp expands your horizon Write an Interpreter and Compiler (understand how a programming language works)   LISP is worth learning for a different reason — the profound enlightenment experience you will have when you finally get it. - Eric S. Raymond\n Paradigms of AI Programming (PAIP) by Peter Norvig\nLink to book\nThe second best programming book ever written and in a way a continuation of SICP for experienced developers. It contains a lot of code, mainly solving AI problems. The code is full of great advice applicable to modern general programming. You will learn Common Lisp which is eye-opening for itself. Further you are guided how a software developer builds his own tools like logging, debugging and even more important how a developer tackles bigger, complex tasks. Norvig himself is a terrific coder. His code is the most elegant I ever read. He also maintains a Github repository called pytudes where he collects nifty Python programs. For example you can find there Norvig’s exquisite AdventOfCode solutions.\nHighlights:\n Enjoy one of the most elegant codebase ever written Learn Lisp Create an OOP system from scratch in a few hundred lines of code! Write famous classic AI systems: Eliza, Search Algorithms, Solving algebraic equations Advanced programming techniques:  write a Scheme interpreter make it fast as a Compiler Performance optimizations like Memoization, Compilation    The Little Schemer by Daniel P. Friedman and Matthias Felleisen\nLink to book\nA book about recursion. Or let me rephrase: The book about recursion. After you get used to the tutorial question-and-answer style, The Little Schemer is the best resource to understand recursion. At the very end, you will derive the Y-Combinator, which allows anonymous function recursion. A mind-bending experience!\n In order to understand recursion, one must first understand recursion. - Anonymous\n Introduction to Functional Programming 1st Edition by Bird Wadler\nLink to book PDF\nAccording to Erik Meijer, the best introduction to functional programming. For learning purposes, the purely functional programming language Miranda is used. Miranda is an ancestor of Haskell, both belong to the ML family. Once you get the hang of it, it makes you a better programmer in any language.\nHighlights:\n first class function, high-order functions map/filter/reduce Recursive Data Types (Lists, Trees) Currying Pattern Matching Lazy Evaluation/Data Structures  Programming Pearls by Jon Bentley\nLink to book\nTimeless programming lessons packaged in short essays about excellently selected programming topics like data structures, algorithms, sorting, searching, performance. Bentley’s writings are from a time when cpu and memory were scarce and performance optimization were mandatory. But such circumstances make the solutions even more fascinating. The problem treatments are eye-opening and most importantly they are entertaining. The best thing is that all chapters end with crispy exercises in order to intensify your knowledge.\nFun fact: Bentley writes about creating a test harness – long before TDD was a thing.\nThe Algorithm Design Manual by Steven Skiena\nLink to book\nData Structures and Algorithms are the bread and butter for every programmer. Hence a good reference book is essential. I chose The Algorithm Design Manual because it provides the best combination of theory and practice.\nThe book is structured in two parts. The first one is an introduction to algorithm design, Big O notation and standard topics like data structures, sorting, searching, recursion, dynamic programming and graphs. For good measure, each chapter ends with exercises perfectly suited for your coding interview preparation. The second part is the real gem: a wide and well-structured catalog of algorithms and data structures with graphical representations that make searching a breeze. It is actually fun to just browse the catalog because you encounter interesting things at every turn.\nA good alternative is Introduction to Algorithms.\nThe Art Of Programming By Don Knuth\nLink to book\nNo programming book list is complete without Knuth’s magnum opus. Knuth himself received the Turing Award in 1974 and he is generally considered one of the greatest Computer Scientist ever. If you want to go deeper than The Algorithm Design Manual, The Art Of Programming is the way to go.\nHistoric fun fact: Because Knuth was not satisfied with the typesetting systems in the 70s, he invented TeX as a by-product. To the present day, LaTeX, a descendant of TeX, is the prevalent typesetting system in academia for math, physics, chemistry and computer science.\nBrian Kernighan’s Books Kernighan is a master in technical writing. I would go so far to claim that without his outstanding documentation about Unix and the C programming language, both technologies would not become so successful so fast. Good documentation is crucial for computer programs to thrive and to build up a community. He calls Ken Thomson a “singularity in programming”, I call Kernighan a “singularity in technical writing”.\nThe C Programming Language By Brian W. Kernighan, Dennis Richie\nLink to book\nThe book has a legendary status and needs no introduction. It offers a concise and terse tour through the complete C programming language and sets the standard for programming language reference manuals.\nFun fact: The famous Hello, world! program originates from this book.\nThe Practice Of Programming By Brian W. Kernighan, Rob Pike\nLink to book\nA compendium of ageless programming practices, relevant for any programming language and for any skill level.\nHighlights:\n Coding Style Data Structures and Algorithms Designing Programs Traits of good APIs/Interfaces Debugging practices Testing practices Performance, Profiling  The Unix Programming Environment By Brian W. Kernighan, Rob Pike\nLink to book\nOld but Gold! A great guide into the Unix Programming Environment. If you use the shell regularly, it is a fantastic way to get more productive. And if you don’t use the shell, it will convince you that you do!\nSoftware Tools in Pascal By Brian W. Kernighan, P.J. Plauger\nLink to book\nA little forgotten and underrated book, but one of my favorites. The advice in the book is priceless. It explains how to think as a productive programmer, how to approach larger programming tasks from the ground up and how to maintain an ever-growing codebase by using modularization and clear API design based on the Unix philosophy. Working through the book, you will build common Unix tools from scratch. I sometimes use this book in order to learn a new programming language because the exercises are universally applicable and the writing is so enjoyable.\nHighlights:\n Build your own Unix tools  cat find grep a complete editor    Modern Classics Software Engineering At Google by Titus Winters, Tom Manshreck and Hyrum Wright\nLink to book\nA must-read if you work in the software engineering field. The book contains it all: engineering principles, practices, culture, tools, technologies and even management topics for building and maintaining modern software of any scale efficiently and effectively over time.\nAnd the best, it’s free!\nHighlights:\n Gives a glimpse how Google builds software  Designing Data-Intensive Applications by Martin Kleppmann\nLink to book\nYou work in a highly distributed IT landscape with microservices? Then this is a mandatory read for you. Kleppmann magically connects dry distributed systems theory with practical examples and lies down a lucid plan how to pick the best solutions for building real-world applications.\nHighlights:\n Query-Languages Data Storage Engines Encoding Formats (JSON, Protocol Buffers, Thrift, Avro) Data Replication and Partitioning Transactions, ACID Consensus Big Data, Batch/Stream Processing  The Software Architect Elevator by Gregor Hohpe\nLink to book\nWith the rise of Agile and evolutionary architecture, architects are not needed anymore. Wrong! UML diagrams and PowerPoint slides are obsolete, but modern architects ride the Software Architect elevator, i.e. this new kind of architect connects the penthouse (C-levels) with the engine room (software engineers) and all the levels in between. The book is worth reading just because of Gregor’s awesome metaphors. You find a great teaser in his awesome introductory talk.\nBesides metaphors, architects will be equipped with tools to successfully drive digital transformations in large enterprises, detect organizational bottlenecks and unfold complexity in systems of any kind like IT systems or an organization itself. That said, it is a rewarding book for everyone working in IT, not only for (future) architects.\nAccelerate by Nicole Forsgren, Jez Humble, Gene Kim\nLink to book\nThe DevOps book. Based on a four-year research, Accelerate presents the results on what makes up an efficient software company. You learn about practices to improve software development and delivery – both main factors boosting productivity, profitability and market share. At the core, the whole book is directed towards building an high-performance DevOps culture.\nHighlights:\n Four Key Metrics  Lead Time Deployment Frequency Mean Time to Restore Change Failure Rate   Strategies and concrete practices to become a more efficient software company  Automation CI/CD Automatic Testing Customer Feedback Value Stream Working in small batches WIP limits Westrum organisational culture, Learning culture    Learning A Mind For Numbers by Barbara Oakley\nLink to book\nMy personal favorite. The book massively changed the way I approach and learn new topics. I grasp them faster and more deeply. With the methodologies from the book, learning is fun! The corresponding online course Learning how to lean is freely available. As engineers, we never stop learning and this book is your best companion for your learning endeavours.\nHighlights:\n Short Term vs Long Term Memory Focused vs Diffused learning Chunking Spaced Repetition Pomodoro Technique Self-Testing  Management and Leadership The Manager’s Path by Camille Fournier\nLink to book\nYou want to take the next step in your career and want to approach a new position as engineering manager? Or you are already in a leading position and want to improve? Then this book is for you. It is a must-read for every manager. The Manager’s Path provides clear consultation about effective team management with tangible practices and real-world scenarios.\nYou want to stay an engineer? Fine!The Manager’s Path is a great for you too. It illustrates what you can expected from good managers, helps you detect and solve team-related problems or to enable other people. The extended perspective will make you a more precious employee for your organization, e.g with mentoring you can make a big difference:\n How to be a 10x engineer: help ten other engineers be twice as good. - Peter Seibel\n Highlights:\n 1-1s Mentoring Conflict Management Decision Making Debugging dysfunctional teams Dealing problematic team members (brilliant jerk, non-communicator) Covers the whole carrier path from managers to tech leads to directors to CTOs  Leadership Strategy and Tactics: Field Manual by Jocko Willink\nLink to book\nJocko Willink is a former Navy Seal and mastered many life-and-death war situations. His leadership strategies are based on military operations but they are transferable to everyday situations. Leadership is not about a role, but about action and behaviour. Everyone can lead and push his team to better results.\nLike The Manager’s Path, this book focuses on soft skills, especially on leading people in the most successful way to achieve a common goal. Technical hard skills are important but to be most valuable for your team, you need to take ownership and start to lead. Leadership Strategy and Tactics gives you the tools and the guidance for taking over leadership.\n Overly focusing on tech is how you end up with the skills of a senior engineer and the experience of a junior human being. - Kelsey Hightower\n Unix Books from Stevens If you want to deep dive into Unix programming, Network/Socket programming or learn about Network Protocols and their implementations, look no further. The following mentions are all seminal textbooks in their field and will serve you as learning material as well as reference manuals.\nAdvanced Programming in the UNIX Environment by W. Richard Stevens\nLink to book\nUnix Network Programming: The Sockets Networking API Vol 1 by W. Richard Stevens\nLink to book\nTCP/IP Illustrated: The Protocols, Volume 1 by W. Richard Stevens\nLink to book\n","wordCount":"3221","inLanguage":"en","datePublished":"2022-11-04T10:00:00+02:00","dateModified":"2022-11-04T10:00:00+02:00","author":{"@type":"Person","name":"Daniel Gerlach"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://gerlacdt.github.io/posts/programming-books/"},"publisher":{"@type":"Organization","name":"Daniel's programming rants","logo":{"@type":"ImageObject","url":"https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://gerlacdt.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://gerlacdt.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://gerlacdt.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://gerlacdt.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://gerlacdt.github.io/posts/>Posts</a></div><h1 class=post-title>Best Books For The Inquisitive Software Engineer</h1><div class=post-meta><span title="2022-11-04 10:00:00 +0200 +0200">November 4, 2022</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Daniel Gerlach</div></header><div class=post-content><p>This article contains a list of my favorite books with a major impact on my
Software Engineering career. The books are categorized in:</p><ul><li><a href=#software-engineering><em>Software Engineering</em></a></li><li><a href=#programming><em>Programming</em></a></li><li><a href=#brian-kernighans-books><em>Brian Kernighan’s Books</em></a></li><li><a href=#modern-classics><em>Modern Classics</em></a></li><li><a href=#learning><em>Learning</em></a></li><li><a href=#management-and-leadership><em>Management and Leadership</em></a></li><li><a href=#unix-books-from-stevens><em>Unix Books From Stevens</em></a></li></ul><h2 id=software-engineering>Software Engineering<a hidden class=anchor aria-hidden=true href=#software-engineering>#</a></h2><h3 id=a-philosophy-of-software-design>A Philosophy of Software Design<a hidden class=anchor aria-hidden=true href=#a-philosophy-of-software-design>#</a></h3><p>by John Ousterhout</p><p><a href=https://web.stanford.edu/~ouster/cgi-bin/book.php>Link to book</a></p><p align=left><img src=/img/books/philosophy_of_software_design.jpg alt=philosophy_of_software_design class=medium-zoom-image width=200></p><p>A fabulous book to level up your software design skills as an experienced
engineer. The book is full of great advice. You often will relate to your own
experiences (and mistakes). It mainly speaks about how to manage <strong>complexity</strong>
with <em>information hiding</em>, <em>low coupling</em> and <em>high cohesion</em>.</p><p>Highlights:</p><ul><li>shallow vs deep modules</li><li>tactical vs strategic programming</li><li>Design it twice</li><li>Importance of good naming</li><li>Importance of good code comments</li><li>Avoid <em>Classitis</em></li><li>Define errors out of existence</li></ul><h3 id=the-pragmatic-programmer>The Pragmatic Programmer<a hidden class=anchor aria-hidden=true href=#the-pragmatic-programmer>#</a></h3><p>by Dave Thomas and Andrew Hunt</p><p><a href=https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/>Link to book</a></p><p align=left><img src=/img/books/pragmatic_programmer.jpg alt=pragmatic_programmer class=medium-zoom-image width=200></p><p><em>The Pragmatic Programmer</em> is a whirlwind of highly effective programming
practices and a great addition to <em>A Philosophy of Software Design</em>. It focuses
more on practical programming skills and teaches how to approach programming
problems in general. Even after twenty years, it is highly relevant today.</p><p>Highlights:</p><ul><li>DRY principle</li><li>Orthogonal design</li><li>Rubber Ducking</li><li>Broken window theory</li><li>Programming by Coincidence</li><li>Design by Contract</li><li>Importance of Tooling (shell, text manipulation, editor, IDE, version control
etc.)</li></ul><h3 id=code-complete>Code Complete<a hidden class=anchor aria-hidden=true href=#code-complete>#</a></h3><p>by Steve McConnell</p><p><a href=https://en.wikipedia.org/wiki/Code_Complete>Link to book</a></p><p align=left><img src=/img/books/code_complete.jpg alt=code_complete class=medium-zoom-image width=200></p><p>An all-time classic about all facets of programming. In the 90s and the early
2000s, <em>Code Complete</em> was the undisputed <strong>programming bible</strong>. If you want to
learn about the ins and outs of programming, this book is for you.</p><p>Highlights:</p><ul><li>High-Quality Functions</li><li>High-Quality Classes</li><li>High-Quality Software Design</li><li>Good Comments</li><li>Code Tunings</li><li>Testing</li><li>Debugging</li><li><strong>Pseudo Programming Process (PPP)</strong>, an almost forgotten alternative to TDD</li></ul><h3 id=clean-code>Clean Code<a hidden class=anchor aria-hidden=true href=#clean-code>#</a></h3><p>by Robert C. Martin</p><p><a href=https://www.oreilly.com/library/view/clean-code-a/9780136083238/>Link to book</a></p><p align=left><img src=/img/books/clean_code.jpg alt=clean_code class=medium-zoom-image width=200></p><p><em>Clean Code</em> will teach you good programming techniques and styles. It coined
the term <em>clean code</em> and is a great read for junior and medium programmers.
Unfortunately, it aged quite heavily and is has it quirks. What bugged me the
most are the lengthy and hard to comprehend code examples. My personal pet peeve
is the
<a href=https://gist.github.com/gerlacdt/41cf41c1f32093ca2866d35dffc88481>Clean Code prime generator</a>
. Compare this with my
<a href=https://gist.github.com/gerlacdt/772c86b2f592a16ea6303defaf74974f>pragmatic implementation</a>.
On top of that, the mantra-like writing style can cause furious discussions at
work if teammates treat the book as their &ldquo;bible&rdquo;. Nevertheless <em>Clean Code</em>
taught generations of programmers and is rightly considered a classic.</p><p>Highlights:</p><ul><li>Naming things</li><li>Good functions</li><li>Good Classes</li><li>Good/Bad Comments</li><li>TDD flow and Unit Tests</li><li><strong>SOLID principles</strong> (contained in the book but the catchy name was invented
later)</li></ul><h3 id=refactoring>Refactoring<a hidden class=anchor aria-hidden=true href=#refactoring>#</a></h3><p>by Martin Fowler</p><p><a href=https://martinfowler.com/books/refactoring.html>Link to book</a></p><p align=left><img src=/img/books/refactoring.jpg alt=refactoring class=medium-zoom-image width=200></p><p>Martin Fowler is a giant in modern Software Engineering. He was involved in
countless seminal contributions in the last decades. For me <em>Refactoring</em> had
the most impact. The biggest part of the book is a catalog of refactoring
strategies classified into categories like encapsulation, API, inheritance etc.
But the most important thing is: The book teaches <em>how to think as an effective
programmer</em>. More so, <em>Refactoring</em> pinpoints a clear way of writing code
efficiently, always focusing on keeping code complexity low.</p><p>Highlights:</p><ul><li>Refactoring as a design tool</li><li>Writing code efficiently and pragmatically<ul><li>small code changes which are easily reversible</li><li>If you cannot add a feature conveniently, refactor first</li><li>If code is never touched, refactoring is probably a waste of time</li><li>refactoring first, performance tunings later (it&rsquo;s much easier to tune clean
code)</li><li>&ldquo;Always leave the code base healthier than when you found it.&rdquo;</li><li>&ldquo;If someone says their code was broken for couple of days while they are
refactoring, you can be pretty sure they were not refactoring.&rdquo;</li></ul></li><li>Teaches the coherence of Refactoring and TDD<ul><li>refactoring without tests is <strong>not</strong> refactoring</li><li>changing tests during refactoring is a sign of bad design or brittle tests</li></ul></li><li>Detect and Eliminate Code Smells</li></ul><h3 id=test-driven-development>Test-Driven-Development<a hidden class=anchor aria-hidden=true href=#test-driven-development>#</a></h3><p>by Kent Beck</p><p><a href=https://www.oreilly.com/library/view/test-driven-development/0321146530/>Link to book</a></p><p align=left><img src=/img/books/tdd.jpg alt=tdd class=medium-zoom-image width=200></p><p>The best introduction into one of the game-changing programming techniques of
the last decades. It is an outstanding guide for TDD. Still, TDD is a big topic
and a thoughtless use of TDD could end up in a maintenaince burden. For an
outright view, you should consult other resources which consider fallacies like
brittle and flaky tests, overuse of mocks and long-running tests.</p><p>Highlights:</p><ul><li>Real Life Unit Test example (Money Class)</li><li>xUnit Test Framework</li><li>test patterns<ul><li>test isolation</li><li>test first</li><li>test fixtures</li><li>learning an API or a framework with tests</li></ul></li></ul><h3 id=design-patterns>Design Patterns<a hidden class=anchor aria-hidden=true href=#design-patterns>#</a></h3><p>by GoF aka Erich Gamma, John Vlissides, Ralph Johnson, Richard Helm</p><p><a href=https://en.wikipedia.org/wiki/Design_Patterns>Link to book</a></p><p align=left><img src=/img/books/gof.jpg alt=gof class=medium-zoom-image width=200></p><p>A seminal textbook from the 90s. Patterns build the foundation for well designed
OOP systems. The biggest achievement of design patterns is the facilitated
communication between engineers. It is no longer necessary to drone on
programming details but sharing the pattern name is enough.</p><p>Highlights:</p><ul><li>OOP design</li><li>Recurring design patterns explained<ul><li>Singleton</li><li>Visitor</li><li>Adapter</li><li>Builder</li><li>Command</li><li>Facade</li><li>Iterator</li><li>Observer</li></ul></li></ul><h3 id=extreme-programming-explained>Extreme Programming Explained<a hidden class=anchor aria-hidden=true href=#extreme-programming-explained>#</a></h3><p>by Kent Beck</p><p><a href=https://www.oreilly.com/library/view/extreme-programming-explained/0321278658/>Link to book</a></p><p align=left><img src=/img/books/xp.jpg alt=xp class=medium-zoom-image width=200></p><p>The real book about <strong>agile</strong>. All commercial agile frameworks like Scrum,
Kanban and SAFe are based on <em>Extreme Programming (XP)</em>. The practices and
principles presented here are everlasting and can be applied in any contemporary
project.</p><blockquote><p>XP can exist without Scrum. Scrum cannot exist without XP.</p></blockquote><p>Highlights:</p><ul><li>Pair Programming</li><li>Continuous Integration CI/CD</li><li>Daily Deployment</li><li>Cross-functional teams</li><li>Incremental Builds</li><li>Testing early, often and automated (TDD)</li><li>Customer Involvement</li><li>Sustainable Pace</li></ul><h3 id=domain-driven-design>Domain Driven Design<a hidden class=anchor aria-hidden=true href=#domain-driven-design>#</a></h3><p>by Eric Evans</p><p><a href=https://www.domainlanguage.com/ddd/>Link to book</a></p><p align=left><img src=/img/books/ddd.jpg alt=ddd class=medium-zoom-image width=200></p><p>A classic from the early 2000s. It coined the term Domain Driven Design (DDD)
and is still the best way to structure medium- to large-sized business
application. With the rise of microservices, the most influential concepts like
<em>Strategic Design</em>, <em>Ubiquitous Language</em> and <em>Bounded Context</em> are even more
relevant today. Besides the standard tactical design notions like Entities,
Aggregates, Services and Repositories, you can find great refactoring advice
too, e.g. <em>Intention-Revealing Interfaces</em>, <em>Side-Effect-Free functions</em>,
<em>domain class invariants with explicit constraints</em> etc. Alas, DDD is verbose, luckily a
more condensed version with the essential ideas can be found
<a href=https://matfrs2.github.io/RS2/predavanja/literatura/Avram%20A,%20Marinescu%20F.%20-%20Domain%20Driven%20Design%20Quickly.pdf>here</a>.</p><p>Highlights:</p><ul><li>Strategic Design<ul><li>Bounded Context</li></ul></li><li>Ubiquitous language</li><li>Layered Architecture<ul><li>Modules</li><li>Entities, Value Objects, Aggregates</li><li>Services</li><li>Repositories</li><li>Factories</li></ul></li><li>refactorings:<ul><li>intention-revealing interfaces</li><li>domain class invariants</li></ul></li></ul><h3 id=the-mythical-man-month>The Mythical Man-Month<a hidden class=anchor aria-hidden=true href=#the-mythical-man-month>#</a></h3><p>by Fred Brooks</p><p><a href=https://en.wikipedia.org/wiki/The_Mythical_Man-Month>Link to book</a></p><p align=left><img src=/img/books/myth_month.jpg alt=myth_month class=medium-zoom-image width=200></p><p>The last book in the <em>Software Engineering</em> category but the most influential
one. Brooks wrote down his experience of leading the development of IBM&rsquo;s
gigantic OS/360 operating system. The project effort was roughly
<a href=https://about.sourcegraph.com/blog/the-ibm-system-360-the-first-modular-general-purpose-computer>5000 man years</a>.
The book is full of famous quotes, contains seminal <em>Software Engineering</em> ideas
and is clearly a must-read for anyone working in the IT area. After forty years,
highly relevant today!</p><p>Highlights:</p><ul><li><em>Adding manpower to a late software project makes it later.</em></li><li><em>Nine women can&rsquo;t make a baby in one month.</em></li><li>Second System Effect (aka over-engineering)</li><li>No Silver Bullet</li><li>Plan to throw one away (aka prototyping)</li><li>Surgical Team (aka small cross-functional teams)</li></ul><h2 id=programming>Programming<a hidden class=anchor aria-hidden=true href=#programming>#</a></h2><h3 id=structure-and-interpretation-of-computer-programs-sicp>Structure and Interpretation of Computer Programs (SICP)<a hidden class=anchor aria-hidden=true href=#structure-and-interpretation-of-computer-programs-sicp>#</a></h3><p>by Harold Abelson and Gerald Jay Sussman with Julie Sussman</p><p><a href=https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/index.html>Link to book</a></p><p align=left><img src=/img/books/sicp.gif alt=sicp class=medium-zoom-image width=400></p><p><strong>The best programming book ever written</strong>, period. The book is the best
introduction to programming and will teach you all basic concepts a programmer
must know. This includes expressions, procedures, recursion, evaluation and lot
more. Advanced concepts are covered too, like lazy streams, memoization and
concurrency. Exercises at the end of all chapters help you to revise and deepen
the acquired knowledge. A highlight is the implementation of some OOP concepts
like polymorphism and encapsulation from scratch. Experienced Java or C++
developers will be fascinated how simple it can be!</p><p>Nowadays there is also a contemporary
<a href=https://mitpress.mit.edu/9780262543231/structure-and-interpretation-of-computer-programs/>Javascript edition</a>,
but I myself prefer Scheme.</p><p>Highlights</p><ul><li>Great way to learn programming</li><li>Learn timeless programming practices that stick with you forever<ul><li>Pure functions, the assignment statement is introduced at page 220!</li></ul></li><li>Lisp expands your horizon</li><li>Write an Interpreter and Compiler (understand how a programming language
works)</li></ul><blockquote><p>LISP is worth learning for a different reason — the profound enlightenment
experience you will have when you finally get it. - Eric S. Raymond</p></blockquote><h3 id=paradigms-of-ai-programming-paip>Paradigms of AI Programming (PAIP)<a hidden class=anchor aria-hidden=true href=#paradigms-of-ai-programming-paip>#</a></h3><p>by Peter Norvig</p><p><a href=https://github.com/norvig/paip-lisp>Link to book</a></p><p align=left><img src=/img/books/paip.jpg alt=paip class=medium-zoom-image width=200></p><p><strong>The second best programming book ever written</strong> and in a way a continuation of
SICP for experienced developers. It contains a lot of code, mainly solving AI
problems. The code is full of great advice applicable to modern general
programming. You will learn Common Lisp which is eye-opening for itself. Further
you are guided how a software developer builds his own tools like logging,
debugging and even more important how a developer tackles bigger, complex tasks.
Norvig himself is a terrific coder. His code is the most elegant I ever read. He
also maintains a Github repository called
<a href=https://github.com/norvig/pytudes>pytudes</a> where he collects nifty Python
programs. For example you can find there Norvig&rsquo;s exquisite
<a href=https://adventofcode.com/>AdventOfCode</a> solutions.</p><p>Highlights:</p><ul><li>Enjoy one of the most elegant codebase ever written</li><li>Learn Lisp</li><li>Create an OOP system from scratch in a few hundred lines of code!</li><li>Write famous classic AI systems: Eliza, Search Algorithms, Solving algebraic
equations</li><li>Advanced programming techniques:<ul><li>write a Scheme interpreter</li><li>make it fast as a Compiler</li><li>Performance optimizations like Memoization, Compilation</li></ul></li></ul><h3 id=the-little-schemer>The Little Schemer<a hidden class=anchor aria-hidden=true href=#the-little-schemer>#</a></h3><p>by Daniel P. Friedman and Matthias Felleisen</p><p><a href=https://mitpress.mit.edu/9780262560993/the-little-schemer/>Link to book</a></p><p align=left><img src=/img/books/little_schemer.avif alt=little_schemer class=medium-zoom-image width=200></p><p>A book about <em>recursion</em>. Or let me rephrase: <strong>The</strong> book about recursion.
After you get used to the tutorial question-and-answer style, <em>The Little
Schemer</em> is the best resource to understand recursion. At the very end, you will
derive the <a href=https://catonmat.net/derivation-of-ycombinator>Y-Combinator</a>, which
allows anonymous function recursion. A mind-bending experience!</p><blockquote><p>In order to understand recursion, one must first understand recursion. -
Anonymous</p></blockquote><h3 id=introduction-to-functional-programming-1st-edition>Introduction to Functional Programming 1st Edition<a hidden class=anchor aria-hidden=true href=#introduction-to-functional-programming-1st-edition>#</a></h3><p>by Bird Wadler</p><p><a href=https://doc.lagout.org/programmation/Functional%20Programming/Richard_Bird%2C_Philip_Wadler-Introduction_to_Functional_Programming_%28Prentice_Hall_International_Series_in_Computing_Science%29-Prentice_Hall%281988%29.pdf>Link to book PDF</a></p><p align=left><img src=/img/books/intro_func.jpg alt=intro_func class=medium-zoom-image width=200></p><p>According to
<a href=https://twitter.com/headinthebox/status/1511478467421884418>Erik Meijer</a>, the
best introduction to <em>functional programming</em>. For learning purposes, the purely
functional programming language Miranda is used. Miranda is an ancestor of
<em>Haskell</em>, both belong to the
<a href=https://en.wikipedia.org/wiki/ML_(programming_language)>ML family</a>. Once you
get the hang of it, it makes you a better programmer in any language.</p><p>Highlights:</p><ul><li>first class function, high-order functions</li><li>map/filter/reduce</li><li>Recursive Data Types (Lists, Trees)</li><li>Currying</li><li>Pattern Matching</li><li>Lazy Evaluation/Data Structures</li></ul><h3 id=programming-pearls>Programming Pearls<a hidden class=anchor aria-hidden=true href=#programming-pearls>#</a></h3><p>by Jon Bentley</p><p><a href=https://www.oreilly.com/library/view/programming-pearls-second/9780134498058/>Link to book</a></p><p align=left><img src=/img/books/prog_pearls.jpg alt=prog_pearls class=medium-zoom-image width=200></p><p>Timeless programming lessons packaged in short essays about excellently selected
programming topics like data structures, algorithms, sorting, searching,
performance. Bentley&rsquo;s writings are from a time when cpu and memory were scarce
and performance optimization were mandatory. But such circumstances make the
solutions even more fascinating. The problem treatments are eye-opening and most
importantly they are entertaining. The best thing is that all chapters end with
crispy exercises in order to intensify your knowledge.</p><p>Fun fact: Bentley writes about creating a <em>test harness</em> &ndash; long before TDD was
a thing.</p><h3 id=the-algorithm-design-manual>The Algorithm Design Manual<a hidden class=anchor aria-hidden=true href=#the-algorithm-design-manual>#</a></h3><p>by Steven Skiena</p><p><a href=https://www.algorist.com/>Link to book</a></p><p align=left><img src=/img/books/algo_design_manual.jpg alt=algo_design_manual class=medium-zoom-image width=200></p><p>Data Structures and Algorithms are the bread and butter for every programmer.
Hence a good reference book is essential. I chose <em>The Algorithm Design Manual</em>
because it provides the best combination of theory and practice.</p><p>The book is structured in two parts. The first one is an introduction to
algorithm design, <em>Big O notation</em> and standard topics like data structures,
sorting, searching, recursion, dynamic programming and graphs. For good measure,
each chapter ends with exercises perfectly suited for your coding interview
preparation. The second part is the real gem: a wide and well-structured catalog
of algorithms and data structures with graphical representations that make
searching a breeze. It is actually fun to just browse the catalog because you
encounter interesting things at every turn.</p><p>A good alternative is
<a href=https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/>Introduction to Algorithms</a>.</p><h3 id=the-art-of-programming>The Art Of Programming<a hidden class=anchor aria-hidden=true href=#the-art-of-programming>#</a></h3><p>By Don Knuth</p><p><a href=https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming>Link to book</a></p><p align=left><img src=/img/books/art_of_programming.png alt=art_of_programming class=medium-zoom-image width=200></p><p>No programming book list is complete without Knuth&rsquo;s magnum opus. Knuth himself
received the Turing Award in 1974 and he is generally considered one of the
greatest Computer Scientist ever. If you want to go deeper than <em>The Algorithm
Design Manual</em>, <em>The Art Of Programming</em> is the way to go.</p><p>Historic fun fact: Because Knuth was not satisfied with the typesetting systems
in the 70s, he invented <a href=https://en.wikipedia.org/wiki/TeX>TeX</a> as a
by-product. To the present day, <a href=https://en.wikipedia.org/wiki/LaTeX>LaTeX</a>, a
descendant of TeX, is the prevalent typesetting system in academia for math,
physics, chemistry and computer science.</p><h2 id=brian-kernighans-books>Brian Kernighan&rsquo;s Books<a hidden class=anchor aria-hidden=true href=#brian-kernighans-books>#</a></h2><p>Kernighan is a master in technical writing. I would go so far to claim that
without his outstanding documentation about Unix and the C programming language,
both technologies would not become so successful so fast. Good documentation is
crucial for computer programs to thrive and to build up a community. He calls
<a href=https://en.wikipedia.org/wiki/Ken_Thompson>Ken Thomson</a> a
<a href="https://www.youtube.com/watch?v=O9upVbGSBFo">&ldquo;singularity in programming&rdquo;</a>, I
call Kernighan a &ldquo;singularity in technical writing&rdquo;.</p><h3 id=the-c-programming-language>The C Programming Language<a hidden class=anchor aria-hidden=true href=#the-c-programming-language>#</a></h3><p>By Brian W. Kernighan, Dennis Richie</p><p><a href=https://www.cs.princeton.edu/~bwk/cbook.html>Link to book</a></p><p align=left><img src=/img/books/cbook.jpg alt=cbook class=medium-zoom-image width=200></p><p>The book has a legendary status and needs no introduction. It offers a concise
and terse tour through the complete C programming language and sets the standard
for programming language reference manuals.</p><p>Fun fact: The famous <strong>Hello, world!</strong> program originates from this book.</p><h3 id=the-practice-of-programming>The Practice Of Programming<a hidden class=anchor aria-hidden=true href=#the-practice-of-programming>#</a></h3><p>By Brian W. Kernighan, Rob Pike</p><p><a href=https://www.cs.princeton.edu/~bwk/tpop.webpage/>Link to book</a></p><p align=left><img src=/img/books/practice_programming.jpg alt=practice_programming class=medium-zoom-image width=200></p><p>A compendium of ageless programming practices, relevant for any programming
language and for any skill level.</p><p>Highlights:</p><ul><li>Coding Style</li><li>Data Structures and Algorithms</li><li>Designing Programs</li><li>Traits of good APIs/Interfaces</li><li>Debugging practices</li><li>Testing practices</li><li>Performance, Profiling</li></ul><h3 id=the-unix-programming-environment>The Unix Programming Environment<a hidden class=anchor aria-hidden=true href=#the-unix-programming-environment>#</a></h3><p>By Brian W. Kernighan, Rob Pike</p><p><a href=https://www.cs.princeton.edu/~bwk/upe/upe.html>Link to book</a></p><p align=left><img src=/img/books/unix_env.jpg alt=unix_environment class=medium-zoom-image width=200></p><p>Old but Gold! A great guide into the Unix Programming Environment. If you use
the shell regularly, it is a fantastic way to get more productive. And if you
don&rsquo;t use the shell, it will convince you that you do!</p><h3 id=software-tools-in-pascal>Software Tools in Pascal<a hidden class=anchor aria-hidden=true href=#software-tools-in-pascal>#</a></h3><p>By Brian W. Kernighan, P.J. Plauger</p><p><a href=https://www.amazon.com/Software-Tools-Pascal-Brian-Kernighan/dp/0201103427>Link to book</a></p><p align=left><img src=/img/books/sw_tools.jpg alt=software_tools_pascal class=medium-zoom-image width=200></p><p>A little forgotten and underrated book, but one of my favorites. The advice in
the book is priceless. It explains how to think as a productive programmer, how
to approach larger programming tasks from the ground up and how to maintain an
ever-growing codebase by using modularization and clear API design based on the
<a href=https://en.wikipedia.org/wiki/Unix_philosophy>Unix philosophy</a>. Working
through the book, you will build common Unix tools from scratch. I sometimes use
this book in order to learn a new programming language because the exercises are
universally applicable and the writing is so enjoyable.</p><p>Highlights:</p><ul><li>Build your own Unix tools<ul><li>cat</li><li>find</li><li>grep</li><li>a complete editor</li></ul></li></ul><h2 id=modern-classics>Modern Classics<a hidden class=anchor aria-hidden=true href=#modern-classics>#</a></h2><h3 id=software-engineering-at-google>Software Engineering At Google<a hidden class=anchor aria-hidden=true href=#software-engineering-at-google>#</a></h3><p>by Titus Winters, Tom Manshreck and Hyrum Wright</p><p><a href=https://abseil.io/resources/swe-book>Link to book</a></p><p align=left><img src=/img/books/swe_at_google.jpg alt=swe_at_google class=medium-zoom-image width=200></p><p>A must-read if you work in the software engineering field. The book contains it
all: engineering principles, practices, culture, tools, technologies and even
management topics for <strong>building and maintaining modern software of any scale
efficiently and effectively over time</strong>.</p><p>And the best, it&rsquo;s <a href=https://abseil.io/resources/swe-book>free!</a></p><p>Highlights:</p><ul><li>Gives a glimpse how Google builds software</li></ul><h3 id=designing-data-intensive-applications>Designing Data-Intensive Applications<a hidden class=anchor aria-hidden=true href=#designing-data-intensive-applications>#</a></h3><p>by Martin Kleppmann</p><p><a href=https://dataintensive.net/>Link to book</a></p><p align=left><img src=/img/books/dataintensive.png alt=dataintensive class=medium-zoom-image width=300></p><p>You work in a highly distributed IT landscape with microservices? Then this is a
mandatory read for you. Kleppmann magically connects dry distributed systems
theory with practical examples and lies down a lucid plan how to pick the best
solutions for building real-world applications.</p><p>Highlights:</p><ul><li>Query-Languages</li><li>Data Storage Engines</li><li>Encoding Formats (JSON, Protocol Buffers, Thrift, Avro)</li><li>Data Replication and Partitioning</li><li>Transactions, ACID</li><li>Consensus</li><li>Big Data, Batch/Stream Processing</li></ul><h3 id=the-software-architect-elevator>The Software Architect Elevator<a hidden class=anchor aria-hidden=true href=#the-software-architect-elevator>#</a></h3><p>by Gregor Hohpe</p><p><a href=https://architectelevator.com/book/>Link to book</a></p><p align=left><img src=/img/books/architectelevator.jpg alt=architectelevator class=medium-zoom-image width=200></p><p>With the rise of <em>Agile</em> and evolutionary architecture, architects are not
needed anymore. Wrong! UML diagrams and PowerPoint slides are obsolete, but
modern architects ride the <em>Software Architect elevator</em>, i.e. this new kind of
architect connects the penthouse (C-levels) with the engine room (software
engineers) and all the levels in between. The book is worth reading just because
of Gregor&rsquo;s awesome metaphors. You find a great teaser in his awesome
<a href="https://www.youtube.com/watch?v=Zq2VcRZmz78">introductory talk</a>.</p><p>Besides metaphors, architects will be equipped with tools to successfully drive
digital transformations in large enterprises, detect organizational bottlenecks
and unfold complexity in systems of any kind like IT systems or an organization
itself. That said, it is a rewarding book for everyone working in IT, not only
for (future) architects.</p><h3 id=accelerate>Accelerate<a hidden class=anchor aria-hidden=true href=#accelerate>#</a></h3><p>by Nicole Forsgren, Jez Humble, Gene Kim</p><p><a href=https://itrevolution.com/accelerate-book/>Link to book</a></p><p align=left><img src=/img/books/accelerate.webp alt=accelerate class=medium-zoom-image width=200></p><p>The <strong>DevOps</strong> book. Based on a four-year research, <em>Accelerate</em> presents the
results on what makes up an efficient software company. You learn about
practices to improve software development and delivery &ndash; both main factors
boosting productivity, profitability and market share. At the core, the whole
book is directed towards building an high-performance DevOps culture.</p><p>Highlights:</p><ul><li><strong>Four Key Metrics</strong><ul><li><em>Lead Time</em></li><li><em>Deployment Frequency</em></li><li><em>Mean Time to Restore</em></li><li><em>Change Failure Rate</em></li></ul></li><li>Strategies and concrete practices to become a more efficient software company<ul><li>Automation</li><li>CI/CD</li><li>Automatic Testing</li><li>Customer Feedback</li><li>Value Stream</li><li>Working in small batches</li><li>WIP limits</li><li>Westrum organisational culture, Learning culture</li></ul></li></ul><h2 id=learning>Learning<a hidden class=anchor aria-hidden=true href=#learning>#</a></h2><h3 id=a-mind-for-numbers>A Mind For Numbers<a hidden class=anchor aria-hidden=true href=#a-mind-for-numbers>#</a></h3><p>by Barbara Oakley</p><p><a href=https://barbaraoakley.com/books/a-mind-for-numbers/>Link to book</a></p><p>My personal favorite. The book massively changed the way I approach and learn
new topics. I grasp them faster and more deeply. With the methodologies from the
book, learning is fun! The corresponding online course
<a href=https://www.coursera.org/learn/learning-how-to-learn>Learning how to lean</a> is
freely available. As engineers, we never stop learning and this book is your
best companion for your learning endeavours.</p><p>Highlights:</p><ul><li>Short Term vs Long Term Memory</li><li>Focused vs Diffused learning</li><li>Chunking</li><li>Spaced Repetition</li><li>Pomodoro Technique</li><li>Self-Testing</li></ul><p align=left><img src=/img/books/mind_for_numbers.jpg alt=mind_for_numbers class=medium-zoom-image width=200></p><h2 id=management-and-leadership>Management and Leadership<a hidden class=anchor aria-hidden=true href=#management-and-leadership>#</a></h2><h3 id=the-managers-path>The Manager&rsquo;s Path<a hidden class=anchor aria-hidden=true href=#the-managers-path>#</a></h3><p>by Camille Fournier</p><p><a href=https://www.oreilly.com/library/view/the-managers-path/9781491973882/>Link to book</a></p><p align=left><img src=/img/books/manager_path.jpg alt=manager_path class=medium-zoom-image width=200></p><p>You want to take the next step in your career and want to approach a new
position as <em>engineering manager</em>? Or you are already in a leading position and
want to improve? Then this book is for you. It is a must-read for every manager.
<em>The Manager&rsquo;s Path</em> provides clear consultation about effective team management
with tangible practices and real-world scenarios.</p><p>You want to stay an engineer? Fine!<em>The Manager&rsquo;s Path</em> is a great for you too.
It illustrates what you can expected from good managers, helps you detect and
solve team-related problems or to enable other people. The extended perspective
will make you a more precious employee for your organization, e.g with
<em>mentoring</em> you can make a big difference:</p><blockquote><p>How to be a 10x engineer: help ten other engineers be twice as good. -
<a href="https://twitter.com/peterseibel/status/512615519934230528?lang=en">Peter Seibel</a></p></blockquote><p>Highlights:</p><ul><li>1-1s</li><li>Mentoring</li><li>Conflict Management</li><li>Decision Making</li><li>Debugging dysfunctional teams</li><li>Dealing problematic team members (brilliant jerk, non-communicator)</li><li>Covers the whole carrier path from managers to tech leads to directors to CTOs</li></ul><h3 id=leadership-strategy-and-tactics-field-manual>Leadership Strategy and Tactics: Field Manual<a hidden class=anchor aria-hidden=true href=#leadership-strategy-and-tactics-field-manual>#</a></h3><p>by Jocko Willink</p><p><a href=https://www.amazon.com/Leadership-Strategy-Tactics-Field-Manual/dp/1250226848>Link to book</a></p><p align=left><img src=/img/books/leadership_strategy.jpg alt=leadership_strategy class=medium-zoom-image width=200></p><p>Jocko Willink is a former Navy Seal and mastered many life-and-death war
situations. His leadership strategies are based on military operations but they
are transferable to everyday situations. Leadership is not about a role, but
about action and behaviour. Everyone can lead and push his team to better
results.</p><p>Like <em>The Manager&rsquo;s Path</em>, this book focuses on soft skills, especially on
leading people in the most successful way to achieve a common goal. Technical
hard skills are important but to be most valuable for your team, you need to
take ownership and start to lead. <em>Leadership Strategy and Tactics</em> gives you
the tools and the guidance for taking over leadership.</p><blockquote><p>Overly focusing on tech is how you end up with the skills of a senior engineer
and the experience of a junior human being. -
<a href="https://twitter.com/kelseyhightower/status/1393194153681440780?lang=en">Kelsey Hightower</a></p></blockquote><h2 id=unix-books-from-stevens>Unix Books from Stevens<a hidden class=anchor aria-hidden=true href=#unix-books-from-stevens>#</a></h2><p>If you want to deep dive into Unix programming, Network/Socket programming or
learn about Network Protocols and their implementations, look no further. The
following mentions are all seminal textbooks in their field and will serve you
as learning material as well as reference manuals.</p><h3 id=advanced-programming-in-the-unix-environment>Advanced Programming in the UNIX Environment<a hidden class=anchor aria-hidden=true href=#advanced-programming-in-the-unix-environment>#</a></h3><p>by W. Richard Stevens</p><p><a href=http://www.apuebook.com/>Link to book</a></p><p align=left><img src=/img/books/apue.jpg alt=apue class=medium-zoom-image width=200></p><h3 id=unix-network-programming-the-sockets-networking-api-vol-1>Unix Network Programming: The Sockets Networking API Vol 1<a hidden class=anchor aria-hidden=true href=#unix-network-programming-the-sockets-networking-api-vol-1>#</a></h3><p>by W. Richard Stevens</p><p><a href=http://www.kohala.com/start/>Link to book</a></p><p align=left><img src=/img/books/network_prog.jpg alt=network_prog class=medium-zoom-image width=200></p><h3 id=tcpip-illustrated-the-protocols-volume-1>TCP/IP Illustrated: The Protocols, Volume 1<a hidden class=anchor aria-hidden=true href=#tcpip-illustrated-the-protocols-volume-1>#</a></h3><p>by W. Richard Stevens</p><p><a href=http://www.kohala.com/start/>Link to book</a></p><p align=left><img src=/img/books/network_protocol.gif alt=network_protocol class=medium-zoom-image width=200></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://gerlacdt.github.io/tags/programming/>programming</a></li><li><a href=https://gerlacdt.github.io/tags/softwareengineering/>softwareengineering</a></li></ul><nav class=paginav><a class=next href=https://gerlacdt.github.io/posts/software-engineering-feedback-loops/><span class=title>Next Page »</span><br><span>Software Engineering and Feedback Loops</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Best Books For The Inquisitive Software Engineer on twitter" href="https://twitter.com/intent/tweet/?text=Best%20Books%20For%20The%20Inquisitive%20Software%20Engineer&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fprogramming-books%2f&hashtags=programming%2csoftwareengineering"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Best Books For The Inquisitive Software Engineer on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fprogramming-books%2f&title=Best%20Books%20For%20The%20Inquisitive%20Software%20Engineer&summary=Best%20Books%20For%20The%20Inquisitive%20Software%20Engineer&source=https%3a%2f%2fgerlacdt.github.io%2fposts%2fprogramming-books%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Best Books For The Inquisitive Software Engineer on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fprogramming-books%2f&title=Best%20Books%20For%20The%20Inquisitive%20Software%20Engineer"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Best Books For The Inquisitive Software Engineer on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fgerlacdt.github.io%2fposts%2fprogramming-books%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Best Books For The Inquisitive Software Engineer on whatsapp" href="https://api.whatsapp.com/send?text=Best%20Books%20For%20The%20Inquisitive%20Software%20Engineer%20-%20https%3a%2f%2fgerlacdt.github.io%2fposts%2fprogramming-books%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Best Books For The Inquisitive Software Engineer on telegram" href="https://telegram.me/share/url?text=Best%20Books%20For%20The%20Inquisitive%20Software%20Engineer&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fprogramming-books%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://gerlacdt.github.io/>Daniel's programming rants</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>