<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Top 10 Practices Of Effective Software Engineers | Daniel's programming rants</title><meta name=keywords content="programming,softwareengineering"><meta name=description content="TL;DR  Write code Read Code (Written) Communication Learn concepts &ndash; not technologies Learn Lisp Master your tools Control complexity (Simplicity) Read books (but don&rsquo;t forget to practice) Understand the problem domain Learn to write good tests (or how to design well and write decoupled code)  Introduction I am always pondering what practices, tactics, behaviours and approaches make up the most successful software engineers. After 15 years working in the industry, in small and big teams, with waterfall and agile processes, and after thousands of written lines of code, I present here an opinionated way of how to become an effective engineer."><meta name=author content="Daniel Gerlach"><link rel=canonical href=https://gerlacdt.github.io/posts/habits/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4BE9J0ZRDL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4BE9J0ZRDL",{anonymize_ip:!1})}</script><meta property="og:title" content="Top 10 Practices Of Effective Software Engineers"><meta property="og:description" content="TL;DR  Write code Read Code (Written) Communication Learn concepts &ndash; not technologies Learn Lisp Master your tools Control complexity (Simplicity) Read books (but don&rsquo;t forget to practice) Understand the problem domain Learn to write good tests (or how to design well and write decoupled code)  Introduction I am always pondering what practices, tactics, behaviours and approaches make up the most successful software engineers. After 15 years working in the industry, in small and big teams, with waterfall and agile processes, and after thousands of written lines of code, I present here an opinionated way of how to become an effective engineer."><meta property="og:type" content="article"><meta property="og:url" content="https://gerlacdt.github.io/posts/habits/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-11T11:00:00+02:00"><meta property="article:modified_time" content="2023-04-11T11:00:00+02:00"><meta property="og:site_name" content="Daniel's programming rants"><meta name=twitter:card content="summary"><meta name=twitter:title content="Top 10 Practices Of Effective Software Engineers"><meta name=twitter:description content="TL;DR  Write code Read Code (Written) Communication Learn concepts &ndash; not technologies Learn Lisp Master your tools Control complexity (Simplicity) Read books (but don&rsquo;t forget to practice) Understand the problem domain Learn to write good tests (or how to design well and write decoupled code)  Introduction I am always pondering what practices, tactics, behaviours and approaches make up the most successful software engineers. After 15 years working in the industry, in small and big teams, with waterfall and agile processes, and after thousands of written lines of code, I present here an opinionated way of how to become an effective engineer."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://gerlacdt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Top 10 Practices Of Effective Software Engineers","item":"https://gerlacdt.github.io/posts/habits/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Top 10 Practices Of Effective Software Engineers","name":"Top 10 Practices Of Effective Software Engineers","description":"TL;DR  Write code Read Code (Written) Communication Learn concepts \u0026ndash; not technologies Learn Lisp Master your tools Control complexity (Simplicity) Read books (but don\u0026rsquo;t forget to practice) Understand the problem domain Learn to write good tests (or how to design well and write decoupled code)  Introduction I am always pondering what practices, tactics, behaviours and approaches make up the most successful software engineers. After 15 years working in the industry, in small and big teams, with waterfall and agile processes, and after thousands of written lines of code, I present here an opinionated way of how to become an effective engineer.","keywords":["programming","softwareengineering"],"articleBody":"TL;DR  Write code Read Code (Written) Communication Learn concepts ‚Äì not technologies Learn Lisp Master your tools Control complexity (Simplicity) Read books (but don‚Äôt forget to practice) Understand the problem domain Learn to write good tests (or how to design well and write decoupled code)  Introduction I am always pondering what practices, tactics, behaviours and approaches make up the most successful software engineers. After 15 years working in the industry, in small and big teams, with waterfall and agile processes, and after thousands of written lines of code, I present here an opinionated way of how to become an effective engineer.\nWrite Code The most important thing in order to excel in programming is to practice regularly and write a lot of code. One cannot learn programming by only reading books or manuals.\nPeter Norvig‚Äôs seminal article Teach yourself Programming in Ten Years [1] is the perfect guide for your journey to become a well-versed programmer. According to Norvig, learning to program is a marathon. To master a craft, it takes roughly ten thousands hours of practice. Daily exercises and challenging projects are mandatory to progress.\nProgramming is a team sport. Consequently the best way to learn is working on projects with other programmers. Thereby, be the best programmer in one project and mentor other team members. In another project, be the worst programmer and learn from your peers. Talk to other developers and study their practices. How do they approach problems, how do they structure their code, how do they think and what manners make them successful? Learn to work in different kinds of projects, e.g. start a green-field project and design the system from scratch or dive into a big, legacy codebase and maintain it for some time. Different project types will demand different skill sets from you. Also strive for direct feedback and be open for criticism from other developers.\n The only way to learn a new programming language is by writing programs in it.\nDennis Ritchie\n  Computer science education cannot make anybody an expert programmer any more than studying brushes and pigment can make somebody an expert painter.\nEric S. Raymond\n Read Code Code reading is as important as code writing. Maybe even more important [2] because developers spent much more time on reading code than writing code.\nCode Reading skills are crucial in order to get familiar with a new codebase, to perform code reviews or just to understand the existing codebase to make a change.\nBesides that, code can be enjoyable and thrilling like a good book. Nowadays with Github and other Open-Source platforms, code is ubiquitously available. By reading open-source, you get in touch with idiomatic code written by world-class engineers and you will automatically improve your own coding style. Some excellent codebases are:\n Golang Stdlib Java Zookeeper Rust ripgrep  If you have time to dip into your favorite library or framework, you will definitely gain some knowledge and aha moments . Reading the library code can debunk its magic and you can connect the dots. (thinking of Spring Boot and Ruby On Rails)\n(Written) Communication  The craft of programming begins with empathy, not formatting or languages or tools or algorithms or data structures. - Kent Beck\n Most projects fail, not because of the wrong technology or resources, but because of failed communication inside and across teams. Wrongly communicated requirements, wrongly communicated expectations and missed alignments are frequent project killers.\nSince software engineering is a team sport. For that reason verbal and written communication skills are critical. Communication is daily business and happens in all kinds of occasions:\n  Pair Programming, a good session requires a lot of discipline by all participants\n  Code review, good review comments express intentions clearly and respect the author\n  Mentoring\n  Convincing/Advocating\n  Decision-Making process\n  Writing Design Docs\n  Writing software requirements\n  Written communication is particularly important, famous companies like Amazon and Hashicorp have an established writing culture which play a major role in their success stories.\nNot only, we need skills for creating content but also for consuming content. Today, all of us get swamped with information via Emails, Slack messages, code review requests etc. Highly efficient developers process textual information quickly, organize the information in an accessible way and are able to filter the important facts. It is beneficial to invest some time into speed reading or other techniques which let you consume content faster.\nMaybe you think now of counter examples like Linus Torvalds (creator of Linux) or Guido van Rossum (creator of Python). Either of them pulled off his respective project almost alone. But this is only true for the inception phase. On the long-run they created highly active and vivid communities which basically were the result of their great communication skills. Guido is known as the benevolent dictator, Linus is famous for his harsh but direct comments in the Linux Community and his ruthless clean code obsession.\nLearn concepts ‚Äì not technologies New programming languages emerge all the time, the Javascript ecosystem breeds more and more npm-packages and all kind of technologies spring into life. We can never keep up with everything - and it also make no sense. On the contrary, it is very valuable to put in an effort to master the concepts behind technologies. By understanding the foundational concepts, you grasp the problems more thoroughly and hence it enables you to learn related technologies much faster. Without a deeper understanding of the primary concepts, one cannot utilize corresponding technologies adequately. A good example is Node.js, I encountered codebases where it was clear that concepts like async programming and the Event Loop were misunderstood because CPU-intensive tasks were executed inside the single main-thread which led to blocked requests and service outages.\nSoftware Engineering concepts are timeless and can be applied to a certain extent in any programming language. Functional programming is my favorite because it makes your code more readable, testable and maintainable. Incidentally with a bit of effort, one can write functional code in most programming languages. Knowing such a powerful concept, ultimately improves your coding style in general since you are aware of high-order functions, pure functions and immutable (inherently thread-safe) data structures.\nHighly recommended concepts:\nLearning and grasping underlying concepts is crucial but you cannot gain a full understanding without practicing and experimenting. Therefore you must choose a suitable technology and use it accordingly. For programming languages concepts, Lisp is a perfect candidate ü•∞\nLearn Lisp  LISP is worth learning for a different reason ‚Äî the profound enlightenment experience you will have when you finally get it. That experience will make you a better programmer for the rest of your days, even if you never actually use LISP itself a lot.\nEric Steven Raymond [3]\n Lisp empowers you to learn the most important programming language concepts with a single programming language. For example, Lisp supports procedural, functional and object-oriented programming. You learn recursion and get in touch with the power of interactive programming with a REPL (Read-eval-print loop). Further Lisp offers the most terrific meta-programming experience with its macro-system enabled by homoiconicity with S-expressions. Homoiconicity means that Lisp code is constructed of Lisp data-structures. Hence you are able to manipulate Lisp code via Lisp code. A mind-bending experience, if you only programmed in Java or C# all along. With this power at your fingertips, you can implement your own OOP system with objects, classes, inheritance and information hiding in a few hundred lines of Lisp code. For traditional programming languages like C, adding OOP was an enormous PhD task which took multiple years (remember C++). In Lisp it is an undergrad assignment which takes a few days! ü§Ø Implementing concepts yourself is the best way to learn them, that is where Lisp really shines.\n What I cannot build. I do not understand. - Richard Feynman\n If we dig a bit in history, we‚Äôll find out that Lisp is the second oldest programming language, invented in 1958. But Lisp was the first programming language which introduced ground-breaking features like: if-then-else (even if-clauses had to be invented back then), recursive functions, garbage collection, REPL interactive programming, macros, and modifying code at runtime from million miles away [4]. You will figure out that many ‚Äúnew‚Äù features of Java or C# are just copied from Lisp.\nUnfortunately, Lisp‚Äôs powerful abstractions are bane and boon. The ease to implement an OOP system, a package manager or a unit test library led to hundreds of implementations whereby none of them established a standard. Lisp focuses on the highest productivity for an individual. Modern engineering languages like Go or Rust are optimized for team productivity and put their focus on less abstractions but more maintainability.\nLast but not least, two of the best programming books use Lisp: Structure and Interpretation of Computer Programs (SICP) and Paradigms of Artificial Intelligence Programming (PAIP). SICP is the best way to learn programming and with PAIP you will enjoy one of the most elegant codebases ever written.\nMaster your tools Just like a carpenter must be proficient with a hammer and a saw, a software engineer must be proficient with his tools. The most prominent developer tools are the operating system (OS), the programming environment composed of an IDE/editor, a compiler, a build system, a version control system and the programming language itself. Even an Internet browser and ‚Äúknowing how to google‚Äù are parts of a well rounded toolset. The following tasks should be no-brainers for most experienced developers:\n search-and-replace in files navigate fast through a codebase branching, merging, resolving conflicts with a version control system building project with automatic tests writing idiomatic code in your favorite programming language understanding compiler error-stacktraces administrating your local machine with our favorite OS googling a programming question  Software tools are important for an apt programmer, but he should also be trained to use any kind of hardware judiciously, e.g. touch typing with a keyboard. Not only touch typing makes you a faster typist, but you will also detect typos faster on the screen which will lead to a faster feedback loop. Muscle Memory ensures you can focus on the problem instead of wasting brain power for typing.\nMastering all these tools is vital to become more productive. Thereby it is not relevant which specific OS (Linux, Windows) or editor (Emacs, Vim, or an IDE) you adapt. Nevertheless I recommend to invest your efforts in perpetuating tools such as the terminal or classic editors like Vim and Emacs. These tools exist since the ‚Äúdawn‚Äù of computing and probably will be supported forever. Even if they died, modern tools would build upon their legacy and your learning efforts would not be wasted. For instance, Vim keybindings are now supported by most of the popular IDEs. Learning such everlasting tools will prevent you from time-consuming tool switching.\nControl complexity A great software engineer must always strive for simplicity. Continuously managing and controlling complexity is the only way to keep ever-growing projects maintainable. It is a crucial aspect of our craft:\n Controlling complexity is the essence of computer programming.\nBrian Kernighan, P. J. Plauger, Software Tools (1976)\n  The purpose of software engineering is to control complexity, not to create it.\nPamela Zave\n  The art of programming is the art of organizing complexity, of mastering multitude and avoiding its bastard chaos as effectively as possible.\nEdsger W. Dijkstra, Notes on Structured Programming (1970)\n Unfortunately, simple solutions are hard, often much harder than easy workarounds or shortcuts which are near at hand - simple is not easy [5]. Software engineers are permanently tainted by ‚Äúeasy‚Äù solutions due to time pressure or ‚Äúit just works‚Äù mentality. They must resist the urge for such solutions by all means. Complexity is a treacherous beast which does not come with one big bad decision but creeps into the project by hundreds of tiny decisions made on a daily basis. It also boils down to work ethic: are you satisfied with any working solution or do you go the extra mile and make it simple?\n The definition of genius is taking the complex and making it simple.\nAlbert Einstein\n Our main job as software engineers is to retain a project‚Äôs maintainability forever which plays nicely together with controlling complexity:\n Software Engineering encompasses not just the act of writing code, but all of the tools and processes an organization uses to build and maintain that code over time.\nSoftware Engineering At Google\n Complexity comes as in two flavours: essential complexity and accidental complexity. Essential complexity is the complexity of the problem itself and accidental complexity is everything else we add on top with our solution, e.g. solving the wrong problem, wrong technology used, over-engineering, bad software design etc.\nIn A Philosophy of Software Design [6] John Ousterhout defines the main symptoms and causes of software complexity. There are three symptoms. First change amplification: a simple change causes changes in a lot of different places. Second high cognitive load: one must know a lot about the whole system in order to make a small change. Third and the worst symptom is unknown unknowns: one does not even know all places where changes are necessary to implement a feature. All these symptoms are caused by uncontrolled code dependencies and obscure code. Simplicity is the opposite: good modularization restricts information sharing with information hiding and encapsulation, obvious code is easy to comprehend. Alas, most projects accidentally end up as a big ball of mud [7]. A result of reckless information sharing between dependencies and hard to understand, obscure code.\nOther causes of complexity are any form of state [8] and feature bloat. Stateless Design is so desirable and successful because it is much easier to reason about, e.g. stateless microservices or stateless network protocols like HTTP. Feature bloat is often induced by product management which forces tech teams to implement useless features [9]. That is usually the consequence of roadmap-driven development. Another source of feature bloat are gold-plating developers who implement potential, artificial requirements which do not exist yet or over-engineer their design with too flexible and complicated abstractions.\nIn conclusion, developers must manage complexity all the time. The only way to hold complexity in check is continuous and unrelenting refactoring [10]. Constantly clean up your code after adding new features. I allow myself to ‚Äúinvent‚Äù my own acronym for that process: Continuous Clean Code Process (CCCP) üöÄ\n The only way to go fast is to go well. - Uncle Bob\n Read Books Writing is human‚Äôs greatest invention to retain and share knowledge. Books are the epitome of writing and the fastest way to absorb knowledge in a short time. More often than not, book authors are the most experienced engineers who share their wisdom, their solutions and last but not least their mistakes. The later is very important, so you don‚Äôt have to repeat them yourself:\n Those that fail to learn from history are doomed to repeat it. - Winston Churchill\n Since books can be large, they can be time consuming to read that‚Äôs why you have to choose wisely. I recommend to focus on concepts and general principles. But don‚Äôt follow this advice too strictly. If you learn a new technology like a programming language, surely it makes sense to read respective books. Although a good foundational knowledge about programming concepts will massively facilitate and accelerate your learning endeavours. For the curious reader, I shared my favorite books and papers in previous articles.\nA Mind For Numbers [11] is my all-time favorite book about the most important concept itself: learning. It will change how you approach new material. By working your way through it, you will become a more potent and motivated learner. An accompanying Coursera course is freely available. Learning is a lifelong undertaking and every engineer should embrace that.\nUnderstand the problem domain Being the best programmer in the team is not enough. You will be most effective as an engineer if you are able to connect technology with the business problem your trying to solve. A comprehensive view over the problem scope generally reveals completely different solution strategies.\nBe excited about the business itself and related areas like marketing, sales, product design etc. Try to speak the same language like the people in different departments instead of bothering them with tech-jargon. It‚Äôs not coincidence that an ubiquitous language is one of the most influential concepts from Domain Driven Design (DDD).\nWith the newly acquired background information you will be much more valuable for your organization. For example, as an engineer you know what is possible and what not, so you can turn down ‚Äúimpossible‚Äù requirements immediately instead of wasting days or weeks only to come to the same conclusion. Vice versa, as an engineer you know what is technologically feasible thus you can contribute breakthrough ideas nobody else is able to.\nLearn to write good tests In modern software engineering automatic testing is now common practice. Unfortunately, just writing tests for the sake of testing is not enough. Writing good tests is a delicate venture and more often than not, typical test suites turn out to be flaky, brittle and unmaintainable. In these situations, code changes break many tests which leads to high maintenance effort. As a final resolution, teams do not refactor anymore or just abandon tests completely! In contrast, good tests should enable and encourage refactoring. We know already that refactoring is inevitable in order to control complexity and to prevent a big ball of mud.\nBrittle tests are caused by coupling the tests with the system under test (SUT). This violates the main principles of good software design: information hiding and decoupling. Particularly, this is the fault of overusing mocks. Mocking frameworks are affluently available in all programming languages and very easy to integrate. But what most of the people do not know: mocks couple tests with the SUT implementation and make refactorings impossible [12]. Worse yet, mocks require a lot of setup code that pollutes tests and makes them hard to read. Instead of mocks you should use Fakes [13] whenever possible. By using fakes, the SUT implementation will not be exposed. Tests remain decoupled and refactorings possible.\nThe corner pillars of good software design [14] also apply to tests: Decoupling, achieved by information hiding, encapsulation and modularization, is crucial for a maintainable, coherent and long-living codebase.\nFinal Words You made it! I hope you can relate to my selection of the most effective engineering habits. It is a long list, but if you only have one take-away, the most important point is: practice regularly. Programming, and learning in general, is a marathon not a sprint. You will solely improve by continuous exercising.\nReferences  Teach yourself Programming in Ten Years - Peter Norvig When Understanding means Rewriting - Jeff Atwood, Coding Horror Blog How to become a Hacker - Eric Steven Raymond Lisp Remote Debugging From 60 Million Miles Away Simple Made Easy - Rich Hickey A Philosophy of Software Design - John Ousterhout Big Ball Of Mud Out Of The Tar Pit - Ben Mosley, Peter Marks A Plea for Lean Software - Niklaus Wirth Refactoring - Martin Fowler. A Mind For Numbers - Barbara Oakley Software Engineering at Google - Titus Winters, Hyrum Wright and more Mocks aren‚Äôt stubs - Martin Fowler Practical Object-Oriented Design - Sandi Metz  ","wordCount":"3198","inLanguage":"en","datePublished":"2023-04-11T11:00:00+02:00","dateModified":"2023-04-11T11:00:00+02:00","author":{"@type":"Person","name":"Daniel Gerlach"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://gerlacdt.github.io/posts/habits/"},"publisher":{"@type":"Organization","name":"Daniel's programming rants","logo":{"@type":"ImageObject","url":"https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://gerlacdt.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://gerlacdt.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://gerlacdt.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://gerlacdt.github.io/about title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://gerlacdt.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://gerlacdt.github.io/posts/>Posts</a></div><h1 class=post-title>Top 10 Practices Of Effective Software Engineers</h1><div class=post-meta><span title="2023-04-11 11:00:00 +0200 CEST">April 11, 2023</span>&nbsp;¬∑&nbsp;16 min&nbsp;¬∑&nbsp;Daniel Gerlach</div></header><div class=post-content><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><ol><li><a href=#write-code>Write code</a></li><li><a href=#read-code>Read Code</a></li><li><a href=#written-communication>(Written) Communication</a></li><li><a href=#learn-concepts----not-technologies>Learn concepts &ndash; not technologies</a></li><li><a href=#learn-lisp>Learn Lisp</a></li><li><a href=#master-your-tools>Master your tools</a></li><li><a href=#control-complexity>Control complexity (Simplicity)</a></li><li><a href=#read-books>Read books (but don&rsquo;t forget to practice)</a></li><li><a href=#understand-the-problem-domain>Understand the problem domain</a></li><li><a href=#learn-to-write-good-tests>Learn to write good tests (or how to design well and write decoupled code)</a></li></ol><h3 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h3><p>I am always pondering what practices, tactics, behaviours and approaches make up
the most successful software engineers. After 15 years working in the industry,
in small and big teams, with waterfall and agile processes, and after thousands
of written lines of code, I present here an opinionated way of how to become an
effective engineer.</p><h2 id=write-code>Write Code<a hidden class=anchor aria-hidden=true href=#write-code>#</a></h2><p>The most important thing in order to excel in programming is to practice
regularly and write a lot of code. One cannot learn programming by only reading
books or manuals.</p><p>Peter Norvig&rsquo;s seminal article <em>Teach yourself Programming in Ten Years</em>
<a href=http://norvig.com/21-days.html>[1]</a> is the perfect guide for your journey to
become a well-versed programmer. According to Norvig, learning to program is a
marathon. To master a craft, it takes roughly ten thousands hours of practice.
Daily exercises and challenging projects are mandatory to progress.</p><p>Programming is a team sport. Consequently the best way to learn is working on
projects with other programmers. Thereby, be the best programmer in one project
and mentor other team members. In another project, be the worst programmer and
learn from your peers. Talk to other developers and study their practices. How
do they approach problems, how do they structure their code, how do they think
and what manners make them successful? Learn to work in different kinds of
projects, e.g. start a green-field project and design the system from scratch or
dive into a big, legacy codebase and maintain it for some time. Different
project types will demand different skill sets from you. Also strive for direct
feedback and be open for criticism from other developers.</p><blockquote><p><em>The only way to learn a new programming language is by writing programs in
it.</em></p><p><strong>Dennis Ritchie</strong></p></blockquote><blockquote><p><em>Computer science education cannot make anybody an expert programmer any more
than studying brushes and pigment can make somebody an expert painter.</em></p><p><strong>Eric S. Raymond</strong></p></blockquote><h2 id=read-code>Read Code<a hidden class=anchor aria-hidden=true href=#read-code>#</a></h2><p>Code reading is as important as code writing. Maybe even more important
<a href=https://blog.codinghorror.com/when-understanding-means-rewriting/>[2]</a> because
developers spent much more time on reading code than writing code.</p><p align=center><img src=/img/code_reading.png alt=code_reading class=medium-zoom-image width=400></p><p>Code Reading skills are crucial in order to get familiar with a new codebase, to
perform code reviews or just to understand the existing codebase to make a
change.</p><p>Besides that, code can be enjoyable and thrilling like a good book. Nowadays
with Github and other Open-Source platforms, code is ubiquitously available. By
reading open-source, you get in touch with idiomatic code written by world-class
engineers and you will automatically improve your own coding style. Some
excellent codebases are:</p><ul><li><a href=https://pkg.go.dev/std>Golang Stdlib</a></li><li><a href=https://github.com/apache/zookeeper>Java Zookeeper</a></li><li><a href=https://github.com/BurntSushi/ripgrep>Rust ripgrep</a></li></ul><p>If you have time to dip into your favorite library or framework, you will
definitely gain some knowledge and aha moments . Reading the library code can
debunk its <em>magic</em> and you can connect the dots. (thinking of
<a href=https://github.com/spring-projects/spring-boot>Spring Boot</a> and
<a href=https://github.com/rails/rails>Ruby On Rails</a>)</p><h2 id=written-communication>(Written) Communication<a hidden class=anchor aria-hidden=true href=#written-communication>#</a></h2><blockquote><p><em>The craft of programming begins with empathy, not formatting or languages or
tools or algorithms or data structures.</em> - <strong>Kent Beck</strong></p></blockquote><p>Most projects fail, not because of the wrong technology or resources, but
because of failed communication inside and across teams. Wrongly communicated
requirements, wrongly communicated expectations and missed alignments are
frequent project killers.</p><p>Since software engineering is a team sport. For that reason verbal and written
communication skills are critical. Communication is daily business and happens
in all kinds of occasions:</p><ul><li><p>Pair Programming, a good session requires a lot of discipline by all
participants</p></li><li><p>Code review, good review comments express intentions clearly and respect the
author</p></li><li><p>Mentoring</p></li><li><p>Convincing/Advocating</p></li><li><p>Decision-Making process</p></li><li><p>Writing Design Docs</p></li><li><p>Writing software requirements</p></li></ul><p>Written communication is particularly important, famous companies like
<a href=https://www.mad.co/insights/the-mad-six-pager>Amazon</a> and
<a href=https://works.hashicorp.com/articles/writing-practices-and-culture>Hashicorp</a>
have an established writing culture which play a major role in their success
stories.</p><p>Not only, we need skills for creating content but also for consuming content.
Today, all of us get swamped with information via Emails, Slack messages, code
review requests etc. Highly efficient developers process textual information
quickly, organize the information in an accessible way and are able to filter
the important facts. It is beneficial to invest some time into
<a href=https://en.wikipedia.org/wiki/Speed_reading><em>speed reading</em></a> or other
techniques which let you consume content faster.</p><p>Maybe you think now of counter examples like Linus Torvalds (creator of Linux)
or Guido van Rossum (creator of Python). Either of them pulled off his
respective project almost alone. But this is only true for the inception phase.
On the long-run they created highly active and vivid communities which basically
were the result of their great communication skills. Guido is known as the
<em>benevolent dictator</em>, Linus is famous for his harsh but direct comments in the
Linux Community and his ruthless clean code obsession.</p><h2 id=learn-concepts----not-technologies>Learn concepts &ndash; not technologies<a hidden class=anchor aria-hidden=true href=#learn-concepts----not-technologies>#</a></h2><p>New programming languages emerge all the time, the Javascript ecosystem breeds
more and more npm-packages and all kind of technologies spring into life. We can
never keep up with everything - and it also make no sense. On the contrary, it
is very valuable to put in an effort to master the concepts behind technologies.
<strong>By understanding the foundational concepts, you grasp the problems more
thoroughly and hence it enables you to learn related technologies much faster</strong>.
Without a deeper understanding of the primary concepts, one cannot utilize
corresponding technologies adequately. A good example is Node.js, I encountered
codebases where it was clear that concepts like <em>async programming</em> and the
<em>Event Loop</em> were misunderstood because CPU-intensive tasks were executed inside
the single main-thread which led to blocked requests and service outages.</p><p><em>Software Engineering</em> concepts are timeless and can be applied to a certain
extent in any programming language. <em>Functional programming</em> is my favorite
because it makes your code more readable, testable and maintainable.
Incidentally with a bit of effort, one can write functional code in most
programming languages. Knowing such a powerful concept, ultimately improves your
coding style in general since you are aware of high-order functions, pure
functions and immutable (inherently thread-safe) data structures.</p><p>Highly recommended concepts:</p><p align=center><img src=/img/concepts.png alt=concepts_to_learn class=medium-zoom-image width=800></p><p>Learning and grasping underlying concepts is crucial but you cannot gain a full
understanding without practicing and experimenting. Therefore you must choose a
suitable technology and use it accordingly. For programming languages concepts,
<em>Lisp</em> is a perfect candidate ü•∞</p><h2 id=learn-lisp>Learn Lisp<a hidden class=anchor aria-hidden=true href=#learn-lisp>#</a></h2><blockquote><p><em>LISP is worth learning for a different reason ‚Äî the profound enlightenment
experience you will have when you finally get it. That experience will make
you a better programmer for the rest of your days, even if you never actually
use LISP itself a lot.</em></p><p><strong>Eric Steven Raymond</strong> <a href=http://www.catb.org/~esr/faqs/hacker-howto.html>[3]</a></p></blockquote><p>Lisp empowers you to learn the most important programming language concepts with
a single programming language. For example, Lisp supports <em>procedural,
functional and object-oriented programming</em>. You learn <em>recursion</em> and get in
touch with the power of <em>interactive programming with a REPL (Read-eval-print
loop)</em>. Further Lisp offers the most terrific <em>meta-programming</em> experience with
its macro-system enabled by <em>homoiconicity with S-expressions</em>. Homoiconicity
means that Lisp code is constructed of Lisp data-structures. Hence you are able
to manipulate Lisp code via Lisp code. A mind-bending experience, if you only
programmed in Java or C# all along. With this power at your fingertips, you can
implement your own <em>OOP system</em> with objects, classes, inheritance and
information hiding in a few hundred lines of Lisp code. For traditional
programming languages like C, adding OOP was an enormous PhD task which took
multiple years (remember C++). In Lisp it is an undergrad assignment which takes
a few days! ü§Ø Implementing concepts yourself is the best way to
learn them, that is where Lisp really shines.</p><blockquote><p><em>What I cannot build. I do not understand.</em> - <strong>Richard Feynman</strong></p></blockquote><p>If we dig a bit in history, we&rsquo;ll find out that Lisp is the second oldest
programming language, invented in 1958. But Lisp was the first programming
language which introduced ground-breaking features like: if-then-else (even
if-clauses had to be invented back then), recursive functions, garbage
collection, REPL interactive programming, macros, and modifying code at runtime
from million miles away <a href=https://youtu.be/_gZK0tW8EhQ>[4]</a>. You will figure out
that many &ldquo;new&rdquo; features of Java or C# are just copied from Lisp.</p><p align=center><img src=/img/lisp_cycles.png alt=lisp_cycles class=medium-zoom-image width=600></p><p>Unfortunately, Lisp&rsquo;s powerful abstractions are bane and boon. The ease to
implement an OOP system, a package manager or a unit test library led to
hundreds of implementations whereby none of them established a standard. Lisp
focuses on the highest productivity for an individual. Modern <em>engineering
languages like Go or Rust</em> are optimized for team productivity and put their
focus on less abstractions but more maintainability.</p><p>Last but not least, two of the best programming books use Lisp: <em>Structure and
Interpretation of Computer Programs</em>
<a href=http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/>(SICP)</a>
and <em>Paradigms of Artificial Intelligence Programming</em>
<a href=https://github.com/norvig/paip-lisp>(PAIP)</a>. SICP is the best way to learn
programming and with PAIP you will enjoy one of the most elegant codebases ever
written.</p><h2 id=master-your-tools>Master your tools<a hidden class=anchor aria-hidden=true href=#master-your-tools>#</a></h2><p>Just like a carpenter must be proficient with a hammer and a saw, a software
engineer must be proficient with his tools. The most prominent developer tools
are the operating system (OS), the programming environment composed of an
IDE/editor, a compiler, a build system, a version control system and the
programming language itself. Even an Internet browser and &ldquo;knowing how to
google&rdquo; are parts of a well rounded toolset. The following tasks should be
no-brainers for most experienced developers:</p><ul><li>search-and-replace in files</li><li>navigate fast through a codebase</li><li>branching, merging, resolving conflicts with a version control system</li><li>building project with automatic tests</li><li>writing idiomatic code in your favorite programming language</li><li>understanding compiler error-stacktraces</li><li>administrating your local machine with our favorite OS</li><li>googling a programming question</li></ul><p>Software tools are important for an apt programmer, but he should also be
trained to use any kind of hardware judiciously, e.g. touch typing with a
keyboard. Not only touch typing makes you a faster typist, but you will also
detect typos faster on the screen which will lead to a faster feedback loop.
Muscle Memory ensures you can focus on the problem instead of wasting brain
power for typing.</p><p>Mastering all these tools is vital to become more productive. Thereby it is not
relevant which specific OS (Linux, Windows) or editor (Emacs, Vim, or an IDE)
you adapt. Nevertheless I recommend to invest your efforts in perpetuating tools
such as the terminal or classic editors like Vim and Emacs. These tools exist
since the &ldquo;dawn&rdquo; of computing and probably will be supported forever. Even if
they died, modern tools would build upon their legacy and your learning efforts
would not be wasted. For instance, Vim keybindings are now supported by most of
the popular IDEs. Learning such everlasting tools will prevent you from
time-consuming tool switching.</p><h2 id=control-complexity>Control complexity<a hidden class=anchor aria-hidden=true href=#control-complexity>#</a></h2><p>A great software engineer must always strive for <strong>simplicity</strong>. Continuously
managing and controlling complexity is the only way to keep ever-growing
projects maintainable. It is a crucial aspect of our craft:</p><blockquote><p><em>Controlling complexity is the essence of computer programming.</em></p><p><strong>Brian Kernighan, P. J. Plauger, Software Tools (1976)</strong></p></blockquote><blockquote><p><em>The purpose of software engineering is to control complexity, not to create
it.</em></p><p><strong>Pamela Zave</strong></p></blockquote><blockquote><p><em>The art of programming is the art of organizing complexity, of mastering
multitude and avoiding its bastard chaos as effectively as possible.</em></p><p><strong>Edsger W. Dijkstra, Notes on Structured Programming (1970)</strong></p></blockquote><p>Unfortunately, simple solutions are hard, often much harder than easy
workarounds or shortcuts which are near at hand - simple is not easy
<a href="https://www.youtube.com/watch?v=SxdOUGdseq4">[5]</a>. Software engineers are
permanently tainted by &ldquo;easy&rdquo; solutions due to time pressure or &ldquo;it just works&rdquo;
mentality. They must resist the urge for such solutions by all means. Complexity
is a treacherous beast which does not come with one big bad decision but creeps
into the project by hundreds of tiny decisions made on a daily basis. It also
boils down to work ethic: are you satisfied with any working solution or do you
go the extra mile and make it <em>simple</em>?</p><blockquote><p><em>The definition of genius is taking the complex and making it simple.</em></p><p><strong>Albert Einstein</strong></p></blockquote><p>Our main job as software engineers is to retain a project&rsquo;s maintainability
forever which plays nicely together with controlling complexity:</p><blockquote><p><em>Software Engineering encompasses not just the act of writing code, but all of
the tools and processes an organization uses to build and maintain that code
over time.</em></p><p><strong>Software Engineering At Google</strong></p></blockquote><p>Complexity comes as in two flavours: <em>essential complexity</em> and <em>accidental
complexity</em>. Essential complexity is the complexity of the problem itself and
accidental complexity is everything else we add on top with our solution, e.g.
solving the wrong problem, wrong technology used, over-engineering, bad software
design etc.</p><p>In <em>A Philosophy of Software Design</em>
<a href=https://web.stanford.edu/~ouster/cgi-bin/book.php>[6]</a> John Ousterhout defines
the main symptoms and causes of software complexity. There are three symptoms.
First <em>change amplification</em>: a simple change causes changes in a lot of
different places. Second <em>high cognitive load</em>: one must know a lot about the
whole system in order to make a small change. Third and the worst symptom is
<em>unknown unknowns</em>: one does not even know all places where changes are
necessary to implement a feature. All these symptoms are caused by <em>uncontrolled
code dependencies</em> and <em>obscure code</em>. Simplicity is the opposite: good
modularization restricts information sharing with information hiding and
encapsulation, <strong>obvious</strong> code is easy to comprehend. Alas, most projects
accidentally end up as a <em>big ball of mud</em>
<a href=http://www.laputan.org/mud/mud.html#BigBallOfMud>[7]</a>. A result of reckless
information sharing between dependencies and hard to understand, obscure code.</p><p align=center><img src=/img/complexity-meme.jpg alt=complexity-meme class=medium-zoom-image width=400></p><p>Other causes of complexity are any form of <strong>state</strong>
<a href=https://curtclifton.net/papers/MoseleyMarks06a.pdf>[8]</a> and feature bloat.
<em>Stateless Design</em> is so desirable and successful because it is much easier to
reason about, e.g. stateless microservices or stateless network protocols like
HTTP. Feature bloat is often induced by product management which forces tech
teams to implement useless features <a href=https://cr.yp.to/bib/1995/wirth.pdf>[9]</a>.
That is usually the consequence of roadmap-driven development. Another source of
feature bloat are <em>gold-plating</em> developers who implement potential, artificial
requirements which do not exist yet or over-engineer their design with too
flexible and complicated abstractions.</p><p>In conclusion, developers must manage complexity all the time. The only way to
hold complexity in check is continuous and unrelenting <em>refactoring</em>
<a href=https://martinfowler.com/books/refactoring.html>[10]</a>. Constantly clean up
your code after adding new features. I allow myself to &ldquo;invent&rdquo; my own acronym
for that process: <strong>Continuous Clean Code Process (CCCP)</strong> üöÄ</p><blockquote><p>The only way to go fast is to go well. - <strong>Uncle Bob</strong></p></blockquote><h2 id=read-books>Read Books<a hidden class=anchor aria-hidden=true href=#read-books>#</a></h2><p>Writing is human&rsquo;s greatest invention to retain and share knowledge. Books are
the epitome of writing and the fastest way to absorb knowledge in a short time.
More often than not, book authors are the most experienced engineers who share
their wisdom, their solutions and last but not least their mistakes. The later
is very important, so you don&rsquo;t have to repeat them yourself:</p><blockquote><p>Those that fail to learn from history are doomed to repeat it. - <strong>Winston
Churchill</strong></p></blockquote><p>Since books can be large, they can be time consuming to read that&rsquo;s why you have
to choose wisely. I recommend to focus on
<a href=#learn-concepts----not-technologies>concepts and general principles</a>. But
don&rsquo;t follow this advice too strictly. If you learn a new technology like a
programming language, surely it makes sense to read respective books. Although a
good foundational knowledge about programming concepts will massively facilitate
and accelerate your learning endeavours. For the curious reader, I shared my
favorite <a href=../programming-books>books</a> and <a href=../classic-papers>papers</a> in
previous articles.</p><p><em>A Mind For Numbers</em> <a href=https://barbaraoakley.com/books/a-mind-for-numbers/>[11]</a>
is my all-time favorite book about the most important concept itself:
<strong>learning</strong>. It will change how you approach new material. By working your way
through it, you will become a more potent and motivated learner. An accompanying
<a href=https://www.coursera.org/learn/learning-how-to-learn>Coursera course</a> is
freely available. Learning is a lifelong undertaking and every engineer should
embrace that.</p><p align=center><img src=/img/learning-too-old.jpg alt=learning-too-old class=medium-zoom-image width=400></p><h2 id=understand-the-problem-domain>Understand the problem domain<a hidden class=anchor aria-hidden=true href=#understand-the-problem-domain>#</a></h2><p>Being the best programmer in the team is not enough. You will be most effective
as an engineer if you are able to connect technology with the business problem
your trying to solve. A comprehensive view over the problem scope generally
reveals completely different solution strategies.</p><p>Be excited about the business itself and related areas like marketing, sales,
product design etc. Try to speak the same language like the people in different
departments instead of bothering them with tech-jargon. It&rsquo;s not coincidence
that an <em>ubiquitous language</em> is one of the most influential concepts from
Domain Driven Design <a href=https://www.domainlanguage.com/ddd/blue-book/>(DDD)</a>.</p><p>With the newly acquired background information you will be much more valuable
for your organization. For example, as an engineer you know what is possible and
what not, so you can turn down &ldquo;impossible&rdquo; requirements immediately instead of
wasting days or weeks only to come to the same conclusion. Vice versa, as an
engineer you know what is technologically feasible thus you can contribute
breakthrough ideas nobody else is able to.</p><h2 id=learn-to-write-good-tests>Learn to write good tests<a hidden class=anchor aria-hidden=true href=#learn-to-write-good-tests>#</a></h2><p>In modern software engineering automatic testing is now common practice.
Unfortunately, just writing tests for the sake of testing is not enough. Writing
good tests is a delicate venture and more often than not, typical test suites
turn out to be flaky, brittle and unmaintainable. In these situations, code
changes break many tests which leads to high maintenance effort. As a final
resolution, teams do not refactor anymore or just abandon tests completely! In
contrast, good tests should enable and encourage refactoring. We know already
that refactoring is inevitable in order to control complexity and to prevent a
big ball of mud.</p><p>Brittle tests are caused by coupling the tests with the <em>system under test</em>
(SUT). This violates the main principles of good software design: <em>information
hiding</em> and <em>decoupling</em>. Particularly, this is the fault of overusing mocks.
Mocking frameworks are affluently available in all programming languages and
very easy to integrate. But what most of the people do not know: <strong>mocks couple
tests with the SUT implementation and make refactorings impossible</strong>
<a href=https://abseil.io/resources/swe-book>[12]</a>. Worse yet, mocks require a lot of
setup code that pollutes tests and makes them hard to read. Instead of mocks you
should use <em>Fakes</em>
<a href=https://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs>[13]</a>
whenever possible. By using fakes, the SUT implementation will not be exposed.
Tests remain decoupled and refactorings possible.</p><p align=center><img src=/img/tests-diagram.png alt=tests-diagram class=medium-zoom-image width=800></p><p align=center><img src=/img/test-cycle.png alt=tests-cycle class=medium-zoom-image width=800></p><p>The corner pillars of good software design <a href=https://www.poodr.com/>[14]</a> also
apply to tests: Decoupling, achieved by information hiding, encapsulation and
modularization, is crucial for a maintainable, coherent and long-living
codebase.</p><h2 id=final-words>Final Words<a hidden class=anchor aria-hidden=true href=#final-words>#</a></h2><p>You made it! I hope you can relate to my selection of the most effective
engineering habits. It is a long list, but if you only have one take-away, the
most important point is: <strong>practice regularly</strong>. Programming, and learning in
general, is a marathon not a sprint. You will solely improve by continuous
exercising.</p><h3 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h3><ol><li><a href=http://norvig.com/21-days.html>Teach yourself Programming in Ten Years - Peter Norvig</a></li><li><a href=https://blog.codinghorror.com/when-understanding-means-rewriting/>When Understanding means Rewriting - Jeff Atwood, Coding Horror Blog</a></li><li><a href=http://www.catb.org/~esr/faqs/hacker-howto.html>How to become a Hacker - Eric Steven Raymond</a></li><li><a href=https://youtu.be/_gZK0tW8EhQ>Lisp Remote Debugging From 60 Million Miles Away</a></li><li><a href="https://www.youtube.com/watch?v=SxdOUGdseq4">Simple Made Easy - Rich Hickey</a></li><li><a href=https://web.stanford.edu/~ouster/cgi-bin/book.php>A Philosophy of Software Design - John Ousterhout</a></li><li><a href=http://www.laputan.org/mud/mud.html#BigBallOfMud>Big Ball Of Mud</a></li><li><a href=https://curtclifton.net/papers/MoseleyMarks06a.pdf>Out Of The Tar Pit - Ben Mosley, Peter Marks</a></li><li><a href=https://cr.yp.to/bib/1995/wirth.pdf>A Plea for Lean Software - Niklaus Wirth</a></li><li><a href=https://martinfowler.com/books/refactoring.html>Refactoring - Martin Fowler</a>.</li><li><a href=https://barbaraoakley.com/books/a-mind-for-numbers/>A Mind For Numbers - Barbara Oakley</a></li><li><a href=https://abseil.io/resources/swe-book>Software Engineering at Google - Titus Winters, Hyrum Wright and more</a></li><li><a href=https://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs>Mocks aren&rsquo;t stubs - Martin Fowler</a></li><li><a href=https://www.poodr.com/>Practical Object-Oriented Design - Sandi Metz</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://gerlacdt.github.io/tags/programming/>programming</a></li><li><a href=https://gerlacdt.github.io/tags/softwareengineering/>softwareengineering</a></li></ul><nav class=paginav><a class=prev href=https://gerlacdt.github.io/posts/ddd-solid/><span class=title>¬´ Prev Page</span><br><span>DDD and SOLID: A refactoring story</span></a>
<a class=next href=https://gerlacdt.github.io/posts/effective-cli/><span class=title>Next Page ¬ª</span><br><span>Effective CLI (more productive than an IDE!)</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Top 10 Practices Of Effective Software Engineers on twitter" href="https://twitter.com/intent/tweet/?text=Top%2010%20Practices%20Of%20Effective%20Software%20Engineers&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fhabits%2f&hashtags=programming%2csoftwareengineering"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Top 10 Practices Of Effective Software Engineers on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fhabits%2f&title=Top%2010%20Practices%20Of%20Effective%20Software%20Engineers&summary=Top%2010%20Practices%20Of%20Effective%20Software%20Engineers&source=https%3a%2f%2fgerlacdt.github.io%2fposts%2fhabits%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Top 10 Practices Of Effective Software Engineers on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fhabits%2f&title=Top%2010%20Practices%20Of%20Effective%20Software%20Engineers"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Top 10 Practices Of Effective Software Engineers on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fgerlacdt.github.io%2fposts%2fhabits%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Top 10 Practices Of Effective Software Engineers on whatsapp" href="https://api.whatsapp.com/send?text=Top%2010%20Practices%20Of%20Effective%20Software%20Engineers%20-%20https%3a%2f%2fgerlacdt.github.io%2fposts%2fhabits%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Top 10 Practices Of Effective Software Engineers on telegram" href="https://telegram.me/share/url?text=Top%2010%20Practices%20Of%20Effective%20Software%20Engineers&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fhabits%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://gerlacdt.github.io/>Daniel's programming rants</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>