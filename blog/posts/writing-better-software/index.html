<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Writing better Code | Daniel's programming rants</title><meta name=keywords content="programming,softwareengineering"><meta name=description content="In Joel Spolsky&rsquo;s blog post &ldquo;The Joel Test: 12 Steps to better Code&rdquo;, he describes a test composed of twelve simple yes-no questions. For a yes you get one point. 10 points are acceptable and 12 are perfect. If you have less than 10 points, you will get in trouble with your software &ndash; sooner or later.
For a quick self-check, these are the original questions:
 Do you use source control?"><meta name=author content="Daniel Gerlach"><link rel=canonical href=https://gerlacdt.github.io/posts/writing-better-software/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4BE9J0ZRDL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4BE9J0ZRDL",{anonymize_ip:!1})}</script><meta property="og:title" content="Writing better Code"><meta property="og:description" content="In Joel Spolsky&rsquo;s blog post &ldquo;The Joel Test: 12 Steps to better Code&rdquo;, he describes a test composed of twelve simple yes-no questions. For a yes you get one point. 10 points are acceptable and 12 are perfect. If you have less than 10 points, you will get in trouble with your software &ndash; sooner or later.
For a quick self-check, these are the original questions:
 Do you use source control?"><meta property="og:type" content="article"><meta property="og:url" content="https://gerlacdt.github.io/posts/writing-better-software/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-08-16T18:38:45+02:00"><meta property="article:modified_time" content="2020-08-16T18:38:45+02:00"><meta property="og:site_name" content="Daniel's programming rants"><meta name=twitter:card content="summary"><meta name=twitter:title content="Writing better Code"><meta name=twitter:description content="In Joel Spolsky&rsquo;s blog post &ldquo;The Joel Test: 12 Steps to better Code&rdquo;, he describes a test composed of twelve simple yes-no questions. For a yes you get one point. 10 points are acceptable and 12 are perfect. If you have less than 10 points, you will get in trouble with your software &ndash; sooner or later.
For a quick self-check, these are the original questions:
 Do you use source control?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://gerlacdt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Writing better Code","item":"https://gerlacdt.github.io/posts/writing-better-software/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Writing better Code","name":"Writing better Code","description":"In Joel Spolsky\u0026rsquo;s blog post \u0026ldquo;The Joel Test: 12 Steps to better Code\u0026rdquo;, he describes a test composed of twelve simple yes-no questions. For a yes you get one point. 10 points are acceptable and 12 are perfect. If you have less than 10 points, you will get in trouble with your software \u0026ndash; sooner or later.\nFor a quick self-check, these are the original questions:\n Do you use source control?","keywords":["programming","softwareengineering"],"articleBody":"In Joel Spolsky’s blog post “The Joel Test: 12 Steps to better Code”, he describes a test composed of twelve simple yes-no questions. For a yes you get one point. 10 points are acceptable and 12 are perfect. If you have less than 10 points, you will get in trouble with your software – sooner or later.\nFor a quick self-check, these are the original questions:\n Do you use source control? Can you make a build in one step? Do you make daily builds? Do you have a bug database? Do you fix bugs before writing new code? Do you have an up-to-date schedule? Do you have a spec? Do programmers have quiet working conditions? Do you use the best tools money can buy? Do you have testers? Do new candidates write code during their interview? Do you do hallway usability testing?  Although Joel’s Test is still an excellent indicator for good software development and engineering, 20 years have past and many game changing technologies have emerged like mobile apps, the public cloud and in general better tooling is available. The success of git and github changed how we develop software. In this article I want to extend Joel’s test with contemporary questions:\nDo you enforce a common code styleguide? Do you write tests? Do you conduct code reviews? Do your developers write documentation? Do you focus on code health? Do you practice continuous integration? Do you have a mentoring program? Is your infrastructure reproducible? Are you doing your best to keep your engineers? Do you provide the best technology for your developers? Do you focus on the four key metrics? Do you empower your developers?  The extended test consists of 24 yes-no questions. As with Joel’s Test, for a yes you get one point. The ranking is:\n 21 points, you are ok 22, 23 points, you are a high-performer 24 points, you are best-in-class  Further I want to emphasis that sustainablity is my main intention for the test. Many questions contribute directly or indirectly to a sustainable and healthy codebase which is crucial for a successful long-term software project and in general for a successful software company. Titus Winters defines a sustainable codebase as:\n Your organization’s codebase is sustainable when you are able to change all of the things that you ought to change, safety, and can do so for the lifetime of your codebase.\n 13. Do you enforce a common code styleguide? Consistency is one of the most important properties of a codebase. It bolsters readability and maintainability which are essential for sustainable code. A consistent codebase is easier to grasp and makes onboarding new developers faster. New programmers are guided by the prevailing style and can adapt quickly to it. Consistency is also an indicator for coders’ discipline, clearly you don’t want to have dead code, unused imports, wrong indentations, and other intricacies in your codebase. The desired consistency can be achieved by a code styleguide.\nAt best you enforce the rules of the styleguide via tooling like static code analyzers, linters and autoformatting tools. Often these tools are integrated into the build or are executed before a commit. Further there are also manually measures like code reviews to enforce a common style.\nA consistent style increases productivity, e.g. linters prevent sloppy programming errors, autoformatters leave no room for useless (sometimes religious) discussions about indentation and formatting rules. All code looks the same. Developers’ taste and ego take a back seat.\n14. Do you write tests? Writing automatic test is a major trait of a sustainable codebase. There are many kind of tests but the best known classification comes with the Test Pyramid.\n Unit Tests Service Tests User Interface Tests  Particularly unit tests build the foundation and give developers confidence to move fast and not to break existing functionality. Unit testing is a major pillar of a fast feedback loop. This keeps developers happy and the quality high. In general, tests act as a safety net, prevent new bugs from being introduced and old bugs from reoccurrence.\nWithout automatic tests your codebase will erode and only long-term developers will be capable to make changes. Onboarding new developers will take months or will never succeed at all. Over time developer speed will slow down and finally come to a complete halt. Heavily relying on manual testing before a release is a clear indicator of missing automatic tests and extends the release cycle by days or weeks. High performers deploy on a daily basis which is not possible with manual testing phases. Therefore manual testing should be reduced to a minimum or completely avoided.\nEstablishing a good testing culture is especially important. E.g.\n no code changes without a corresponding test no bugfix without a test demonstrating the bug is indeed fixed unit test should be fast, so developers run them continuously unit test code coverage should be at a reasonable level like ~70%  At Google, they practice the Beyonce Rule “If you liked it, you shoulda put a test on it!” This rule inverts responsibility, e.g. if someone breaks a feature and there was no test, the original author of the broken feature “shoulda put a test on it!”.\n15. Do you conduct code reviews? Code reviews are a critical step in your software engineering process. Not only they prevent entering bugs into your mainline but they are a major tool for knowledge transfer, learning and mentoring. The code review process fosters a common understanding between reviewers and author and offers a platform for discussions about trade-offs and design decisions. Reviews are not only focused on correctness but also on readability, performance and other non-functional properties.\nAll of that will lead to better solutions. Further reviewers practice their code reading skill which is as important as code writing. Besides compiling, linting and running tests, code reviews form a major step in a developers feedback loop. Code should never be committed into mainline without a proper code review.\nBecause code reviews can conjure up heated discussions, reviewers should comply to some code review guidelines in order to guarantee a flawless experience.\n16. Do developers write documentation? Documentation starts with the code. Code comments or a good description of a pull request are good examples. Thereby good documentation focuses on why something was done. An extensive README.md acts as the “front-page” of a project and should contain its purpose and instructions for developers to set up their local environment for development, e.g installing prerequisites, building the project, running the tests.\nAdditionally a variety of documents with different purposes exist:\n Design Docs (showing alternative solutions, why was one approach chosen over the others?) Architecture Diagrams (System overview, showing coherence between components) Operational Playbooks for Software Reliability Engineers (SREs) (operational instructions for fighting outages)  All these documents should be written by developers, operators or other technical people. Living, up-to-date documentation makes a project more understandable and long-term project members are capable of answering questions why things were done in the past – in the majority of projects, the top answer is “this is historically grown”. The only way to get real insights is conducting time consuming face-to-face interviews. Documentation helps to keep an overview over an ever-growing project, to facilitate the start for new developers and to build a searchable knowledge base. Past decisions should be transparent through good documentation and not hidden in people’s heads.\n17. Do you focus on code health? A healthy codebase is a major criteria for developer happiness. If your developers working on a shitty codebase, they adapt to the poor quality or leave. The existing codebase act as a role model. For the purpose of high quality code, it is important to continuously focus on code health. The best coders are repelled by bad code and attracted by healthy code. But what is a healthy codebase?\nA codebase is healthy when:\n you have fast builds you have an easy development setup you have fast and maintainable tests you have clean, readable, loosely coupled and consistent code you can easily debug the system you continuously tackle technical debt  You can find a much more exhaustive explanation of code health in Google’s Testing Blog about Code Health.\nSigns of bad code are:\n complicated developer setup hard to debug, missing monitoring, noisy garbage logs long build times inconsistent code (dead code, unused imports, different formatting styles, no code styleguide) large merge conflicts due to long running feature branches, broken mainline no tests, flaky tests, hard-maintainable tests because of mocking overuse  Never trade dirty code or workarounds due to time or release pressure for code health. You will end up very badly in the long run. Worse yet, you get in a vicious cycle because bad code slows you down and in order to fulfil the next release you add more dirty workarounds. So always prioritize code health, even when it looks counterintuitive at first sight.\n18. Do you practice continuous integration? Nowadays Continuous Integration is hopefully commonplace. At best, you work with trunk-based development and your mainline is always releasable, preferably with feature toggles. Highest priority is to keep the mainline green and a broken build should be fixed immediately. Small and frequent releases prevent bugs or even outages which happen when large releases are done only intermittently.\nCI helps to prevent tedious merge conflict resolutions because your developers regularly commit into mainline. Additionally you will get rid of time consuming integration problems at the end of your implementation phases.\n“Agile”’s main goal is to identify risks as early as possible and not to postpone them till the end of a project. CI supports exactly that. With CI, you will detect integration and design problems early. This allows you to make course correction on the way.\n19. Do you have a mentoring program? Mentoring is a great way to coach new employees. With a mentoring program, you not only foster a consistent engineering culture with best common practices like software methodologies, code styleguides, code reviews, testing culture and other policies across the whole organization but it is mandatory for molding new recruits into a productive team.\nMentored developers are more likely to stay. They feel approved and treated as first-class employees because you invest time and effort in them from the beginning. It is a fantastic way to give raise to great and loyal engineers.\n20. Is your infrastructure reproducible? Today, public cloud providers like AWS and Azure provide APIs to create, update and manage your infrastructure. With the usage of APIs, it is natural to store your whole Infrastructure as Code (IaC).\nSince we are speaking about code, all previous points apply for infrastructure too. You should keep it under version control, conduct code reviews, run tests in you CI pipeline and keep your codebase clean via formating and linting tools. Known tools for infrastructure are Kubernetes manifests, Helm charts, Terraform or AWS Cloudformation.\nA good indicator if your infastructure is reproducable is how you treat your servers, like cattle or pets? Recreation of a failing server should be easier than duct-taping a failing one. Beware of snowflake servers!\n21. Are you doing your best to keep your engineers?  I’ve built a lot of my success off finding these “truly gifted” people, and not settling for ‘B\" and “C” players, but really going for the “A” players. … I found that when you get enough “A” players together, when you go through the incredible work to find five of these “A” players, they REALLY like working with each other because they have never had a chance to do that before. And, they don’t want to work with “B” and “C” players, and so it becomes self-policing, and they only want to hire more “A” players, so you build up these pockets of “A” players, and it propagates …\"\n Steve Jobs\nHiring good engineers is very important but keeping them is too! The best engineering teams share a common mindset. Engineers want to work with other engineers sharing the same interests and approaching the same goals. This creates a virtuous circle, engineers motivate each other in order to achieve the best possible outcomes. Be careful though, a single new hire can disturb an A-player team’s balance. That’s why the hiring process is very important.\nYou should treat your engineers as first-class employees. Companies, recognizing their value, provide tech-specific careers with compensations comparable to high-management salary level.\nFurther, engineering managers play an essential role to keep your engineers (happy). They should know how to code and share the same engineering mindset. If your engineering managers are not technical skilled, your engineers will not take them seriously. Worse yet, they will leave at some point in time because they feel misunderstood.\nYou should strive to hire A players and to keep them.\n22. Do you provide the best technology for your developers? This points extends Joel’s original ninth point “Do you use the best tools money can buy?” Joel focused mainly on software tools running on your local machine like IDEs, editors, compilers, debuggers and also local hardware like a second monitor. All this make your programmers happy and productive. While this is still true, nowadays it takes more than local tooling to keep your developers happy.\nA major pillar of productivity is going to the public cloud like Amazon AWS or Microsoft Azure. Public clouds offer a great work experience for your engineers. The self-service approach is particularly important. Engineers can automate their application stack via APIs and scripts, use the newest technology and operate the complete system without writing tickets and getting approvals from superiors. It enables your developers to take responsibility for the full lifecyle of the application from design, to implementation, to release and to operation. It’s a great productivity booster. If you cannot go to the public cloud due to legal or other restrictions, beware of the on-prem enterprise non-cloud. The enterprise non-cloud is a treacherous thing, it offers modern software stacks like Kubernetes or Prometheus but is fails to deliver the main advantages of the public cloud like real self-service with APIs, elasticity, scalability and a pay-per-usage price model.\nOther kind of tools are equally important, e.g. modern collaboration tools like Google Docs or Office 365 which support parallel collaboration at one document with multiple users, modern communication tools like Slack and a contemporary version control platform like github with integration for code reviews, for CI pipelines and for the public cloud.\n23. Do you focus on the four key metrics? The best way to measure if your engineering department is top-notch, are the four key metrics, defined in fantastic book Accelerate.\nHigh performers strive for:\n Short lead time High deployment frequency Short mean time to restore (MTTR) Low change fail percentage  Some of the above metrics seem contradictory like high deployment frequency and low change fail percentage. But according to the studies of the DevOps Report the best companies perform in all key metrics excellently.\nIf you look for improvements, it is critical to focus on these four key points permanently. Don’t fall prey to expensive agile transformation methodologies like SAFe. Usually they promise a magical and fast performance boost but often the impact turns out as insignificant or even worsens the situation.\n24. Do you empower your developers? Many companies treat their developers as pure delivery teams, i.e. they are used to implement features based on roadmaps defined by leadership and product management departments. Why this is a bad idea, see Marty Cagan’s post “why products fail?”. With this approach you only getting half of their value. Further companies think developer teams can be easily replaced or even outsourced. They are treated as mercenaries but as we know from John Doerr\n we need teams of missionaries, not teams of mercenaries.\n But for an outsourced IT, it is almost impossible to work in missionary mode.\nIn order to get the most of you developer teams, you must hire missionaries and empower them. Empowered developers are first-class employees. Your developers are the best source of innovation because they know the enabling technology. But it is hard to attract, identify and to keep top talent. See, how to hire (11. from Joel’s test) and keep the best.\nEmpowered developers should not only implement predefined features from stakeholders but are invited to come up with their own solutions to satisfy the customer needs. Therefore we should give developers problems to solve, not features to implement. It is mandatory that developers understand the business context. A quick self-check if you have empowered developers:\n Can developers identify themselves with the customers? Do they attend user tests regularly? At best, do your developers use the application themselves? Do they know the pains of the customers or are they shielded away by a wall of stakeholders, business departments, program managers and never have the chance to get in contact with customers? Do your developers drive their own features or do they only get them at the sprint-planning?  Finally empowered engineers means a mindset change in the whole company, see Marty Cagan:\n (the company is) moving from a model where the technology teams exist to “serve the business” to one where they exist to “serve the customers, in ways that work for the business.\n Conclusion Digital companies like Google, Amazon, Facebook, Microsoft or Netflix have these traits in their blood and they live by these standards already for decades. For them, “software” is their core product, they cannot afford piling up technical debt since they would cripple and risk their own future. This is well understood by them. In contrary to non-digital companies with oldschool enterprise IT departments and outsourced IT.\nNon-digital enterprises never considered “software” as a competitive advantage. But slowly even they understand that “software eats the world” and they want to do develop software in-house again. In such situations, missing know-how and “wrong” people with lack of skills are common. This article wants to be a simple and easy applicable guideline for them to establish a good coding mentality and culture with good practices. I hope you can apply the full test and gain some insights about strengths, weaknesses and possible improvements in your company or team.\n","wordCount":"3023","inLanguage":"en","datePublished":"2020-08-16T18:38:45+02:00","dateModified":"2020-08-16T18:38:45+02:00","author":{"@type":"Person","name":"Daniel Gerlach"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://gerlacdt.github.io/posts/writing-better-software/"},"publisher":{"@type":"Organization","name":"Daniel's programming rants","logo":{"@type":"ImageObject","url":"https://gerlacdt.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://gerlacdt.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://gerlacdt.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://gerlacdt.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://gerlacdt.github.io/about title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://gerlacdt.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://gerlacdt.github.io/posts/>Posts</a></div><h1 class=post-title>Writing better Code</h1><div class=post-meta><span title="2020-08-16 18:38:45 +0200 CEST">August 16, 2020</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Daniel Gerlach</div></header><div class=post-content><p>In Joel Spolsky&rsquo;s blog post <a href=https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/>&ldquo;The Joel Test: 12 Steps to better
Code&rdquo;</a>,
he describes a test composed of twelve simple yes-no questions. For a
<strong>yes</strong> you get one point. 10 points are acceptable and 12 are
perfect. If you have less than 10 points, you will get in trouble with
your software &ndash; sooner or later.</p><p>For a quick self-check, these are the original questions:</p><ol><li>Do you use source control?</li><li>Can you make a build in one step?</li><li>Do you make daily builds?</li><li>Do you have a bug database?</li><li>Do you fix bugs before writing new code?</li><li>Do you have an up-to-date schedule?</li><li>Do you have a spec?</li><li>Do programmers have quiet working conditions?</li><li>Do you use the best tools money can buy?</li><li>Do you have testers?</li><li>Do new candidates write code during their interview?</li><li>Do you do hallway usability testing?</li></ol><p>Although Joel&rsquo;s Test is still an excellent indicator for good software
development and engineering, 20 years have past and many game changing
technologies have emerged like mobile apps, the public cloud and in
general better tooling is available. The success of
<a href=https://git-scm.com/>git</a> and <a href=https://github.com/>github</a> changed
how we develop software. In this article I want to extend Joel&rsquo;s test
with contemporary questions:</p><ol start=13><li>Do you enforce a common code styleguide?</li><li>Do you write tests?</li><li>Do you conduct code reviews?</li><li>Do your developers write documentation?</li><li>Do you focus on code health?</li><li>Do you practice continuous integration?</li><li>Do you have a mentoring program?</li><li>Is your infrastructure reproducible?</li><li>Are you doing your best to keep your engineers?</li><li>Do you provide the best technology for your developers?</li><li>Do you focus on the four key metrics?</li><li>Do you empower your developers?</li></ol><p>The extended test consists of 24 yes-no questions. As with Joel&rsquo;s
Test, for a <strong>yes</strong> you get one point. The ranking is:</p><ul><li>&lt;= 20 points, you must improve</li><li>21 points, you are ok</li><li>22, 23 points, you are a high-performer</li><li>24 points, you are best-in-class</li></ul><p>Further I want to emphasis that <strong>sustainablity</strong> is my main intention
for the test. Many questions contribute directly or indirectly to a
sustainable and healthy codebase which is crucial for a successful
long-term software project and in general for a successful software
company. <a href="https://youtu.be/zW-i9eVGU_k?t=197">Titus Winters</a> defines a
sustainable codebase as:</p><blockquote><p>Your organization&rsquo;s codebase is sustainable when you are able to
change all of the things that you ought to change, safety, and can do
so for the lifetime of your codebase.</p></blockquote><h3 id=13-do-you-enforce-a-common-code-styleguide>13. Do you enforce a common code styleguide?<a hidden class=anchor aria-hidden=true href=#13-do-you-enforce-a-common-code-styleguide>#</a></h3><p><strong>Consistency</strong> is one of the most important properties of a codebase.
It bolsters readability and maintainability which are essential for
sustainable code. A consistent codebase is easier to grasp and makes
onboarding new developers faster. New programmers are guided by the
prevailing style and can adapt quickly to it. Consistency is also an
indicator for coders&rsquo; discipline, clearly you don&rsquo;t want to have dead
code, unused imports, wrong indentations, and other intricacies in
your codebase. The desired consistency can be achieved by a code
styleguide.</p><p>At best you enforce the rules of the styleguide via tooling like
static code analyzers, linters and autoformatting tools. Often these
tools are integrated into the build or are executed before a
commit. Further there are also manually measures like <a href=#codereview>code
reviews</a> to enforce a common style.</p><p>A consistent style increases productivity, e.g. linters prevent
sloppy programming errors, autoformatters leave no room for useless
(sometimes religious) discussions about indentation and formatting
rules. All code looks the same. Developers&rsquo; taste and ego take a back
seat.</p><h3 id=14-do-you-write-tests>14. Do you write tests?<a hidden class=anchor aria-hidden=true href=#14-do-you-write-tests>#</a></h3><p>Writing automatic test is a major trait of a sustainable
codebase. There are many kind of tests but the best known
classification comes with the <a href=https://martinfowler.com/articles/practical-test-pyramid.html>Test
Pyramid</a>.</p><ul><li>Unit Tests</li><li>Service Tests</li><li>User Interface Tests</li></ul><p>Particularly <strong>unit tests</strong> build the foundation and give developers
confidence to move fast and not to break existing functionality. Unit
testing is a major pillar of a fast feedback loop. This keeps
developers happy and the quality high. In general, tests act as a
safety net, prevent new bugs from being introduced and old bugs from
reoccurrence.</p><p>Without automatic tests your codebase will erode and only long-term
developers will be capable to make changes. Onboarding new developers
will take months or will never succeed at all. Over time developer
speed will slow down and finally come to a complete halt. Heavily
relying on manual testing before a release is a clear indicator of
missing automatic tests and extends the release cycle by days or
weeks. High performers deploy on a daily basis which is not possible
with manual testing phases. Therefore manual testing should be reduced
to a minimum or completely avoided.</p><p>Establishing a good testing culture is especially important. E.g.</p><ul><li>no code changes without a corresponding test</li><li>no bugfix without a test demonstrating the bug is indeed fixed</li><li>unit test should be fast, so developers run them continuously</li><li>unit test code coverage should be at a reasonable level like ~70%</li></ul><p>At Google, they practice the <a href=https://www.oreilly.com/library/view/software-engineering-at/9781492082781/>Beyonce Rule &ldquo;If you liked it, you
shoulda put a test on
it!&rdquo;</a>
This rule inverts responsibility, e.g. if someone breaks a feature and
there was no test, the original author of the broken feature &ldquo;shoulda
put a test on it!&rdquo;.</p><h3 id=codereview>15. Do you conduct code reviews?<a hidden class=anchor aria-hidden=true href=#codereview>#</a></h3><p>Code reviews are a critical step in your software engineering
process. Not only they prevent entering bugs into your mainline but
they are a major tool for knowledge transfer, learning and mentoring.
The code review process fosters a common understanding between
reviewers and author and offers a platform for discussions about
trade-offs and design decisions. Reviews are not only focused on
correctness but also on readability, performance and other
non-functional properties.</p><p>All of that will lead to better solutions. Further reviewers practice
their code reading skill which is as important as code
writing. Besides compiling, linting and running tests, code reviews
form a major step in a developers feedback loop. Code should never be
committed into mainline without a proper code review.</p><p>Because code reviews can conjure up heated discussions, reviewers
should comply to some <a href=https://google.github.io/eng-practices/review/reviewer/>code review
guidelines</a>
in order to guarantee a flawless experience.</p><h3 id=16-do-developers-write-documentation>16. Do developers write documentation?<a hidden class=anchor aria-hidden=true href=#16-do-developers-write-documentation>#</a></h3><p>Documentation starts with the code. Code comments or a good
description of a pull request are good examples. Thereby good
documentation focuses on <strong>why</strong> something was done. An extensive
<code>README.md</code> acts as the &ldquo;front-page&rdquo; of a project and should contain
its purpose and instructions for developers to set up their local
environment for development, e.g installing prerequisites, building
the project, running the tests.</p><p>Additionally a variety of documents with different purposes exist:</p><ul><li>Design Docs (showing alternative solutions, why was one approach
chosen over the others?)</li><li>Architecture Diagrams (System overview, showing coherence between
components)</li><li>Operational Playbooks for <a href=https://landing.google.com/sre/workbook/chapters/on-call/>Software Reliability Engineers
(SREs)</a>
(operational instructions for fighting outages)</li></ul><p>All these documents should be written by developers, operators or
other technical people. Living, up-to-date documentation makes a
project more understandable and long-term project members are capable
of answering questions why things were done in the past &ndash; in the
majority of projects, the top answer is &ldquo;this is historically grown&rdquo;.
The only way to get real insights is conducting time consuming
face-to-face interviews. Documentation helps to keep an overview over
an ever-growing project, to facilitate the start for new developers
and to build a searchable knowledge base. Past decisions should be
transparent through good documentation and not hidden in people&rsquo;s
heads.</p><h3 id=17-do-you-focus-on-code-health>17. Do you focus on code health?<a hidden class=anchor aria-hidden=true href=#17-do-you-focus-on-code-health>#</a></h3><p>A healthy codebase is a major criteria for developer happiness. If
your developers working on a shitty codebase, they adapt to the poor
quality or leave. The existing codebase act as a <strong>role model</strong>. For
the purpose of high quality code, it is important to continuously
focus on code health. The best coders are repelled by bad code and
attracted by healthy code. But what is a healthy codebase?</p><p>A codebase is healthy when:</p><ul><li>you have fast builds</li><li>you have an easy development setup</li><li>you have fast and maintainable tests</li><li>you have clean, readable, loosely coupled and consistent code</li><li>you can easily debug the system</li><li>you continuously tackle technical debt</li></ul><p>You can find a much more exhaustive explanation of code health in
<a href=https://testing.googleblog.com/2016/08/hackable-projects.html>Google&rsquo;s Testing Blog about Code
Health</a>.</p><p>Signs of bad code are:</p><ul><li>complicated developer setup</li><li>hard to debug, missing monitoring, noisy garbage logs</li><li>long build times</li><li>inconsistent code (dead code, unused imports, different formatting
styles, no code styleguide)</li><li>large merge conflicts due to long running feature branches, broken mainline</li><li>no tests, flaky tests, hard-maintainable tests because of mocking overuse</li></ul><p>Never trade dirty code or workarounds due to time or release pressure
for code health. You will end up very badly in the long run. Worse
yet, you get in a vicious cycle because bad code slows you down and in
order to fulfil the next release you add more dirty workarounds. So
always prioritize code health, even when it looks counterintuitive at
first sight.</p><h3 id=18-do-you-practice-continuous-integration>18. Do you practice continuous integration?<a hidden class=anchor aria-hidden=true href=#18-do-you-practice-continuous-integration>#</a></h3><p>Nowadays Continuous Integration is hopefully commonplace. At best, you
work with trunk-based development and your mainline is always
releasable, preferably with feature toggles. Highest priority is to
keep the mainline green and a broken build should be fixed
immediately. Small and frequent releases prevent bugs or even outages
which happen when large releases are done only intermittently.</p><p>CI helps to prevent tedious merge conflict resolutions because your
developers regularly commit into mainline. Additionally you will get
rid of time consuming integration problems at the end of your
implementation phases.</p><p>&ldquo;Agile&rdquo;&rsquo;s main goal is to identify risks as early as possible and not
to postpone them till the end of a project. CI supports exactly
that. With CI, you will detect integration and design problems
early. This allows you to make course correction on the way.</p><h3 id=19-do-you-have-a-mentoring-program>19. Do you have a mentoring program?<a hidden class=anchor aria-hidden=true href=#19-do-you-have-a-mentoring-program>#</a></h3><p>Mentoring is a great way to coach new employees. With a mentoring
program, you not only foster a consistent engineering culture with
best common practices like software methodologies, code styleguides,
code reviews, testing culture and other policies across the whole
organization but it is mandatory for molding new recruits into a
productive team.</p><p>Mentored developers are more likely to stay. They feel approved and
treated as first-class employees because you invest time and effort in
them from the beginning. It is a fantastic way to give raise to great
and loyal engineers.</p><h3 id=20-is-your-infrastructure-reproducible>20. Is your infrastructure reproducible?<a hidden class=anchor aria-hidden=true href=#20-is-your-infrastructure-reproducible>#</a></h3><p>Today, public cloud providers like AWS and Azure provide APIs to
create, update and manage your infrastructure. With the usage of
APIs, it is natural to store your whole <a href=https://en.wikipedia.org/wiki/Infrastructure_as_code>Infrastructure as Code
(IaC)</a>.</p><p>Since we are speaking about code, all previous points apply for
infrastructure too. You should keep it under version control, conduct
code reviews, run tests in you CI pipeline and keep your codebase
clean via formating and linting tools. Known tools for infrastructure
are <a href=https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/>Kubernetes
manifests</a>,
<a href=https://helm.sh/>Helm charts</a>,
<a href=https://www.terraform.io/>Terraform</a> or <a href=https://aws.amazon.com/cloudformation/>AWS
Cloudformation</a>.</p><p>A good indicator if your infastructure is reproducable is how you
treat your servers, like <a href="http://www.pass.org/eventdownload.aspx?suid=1902">cattle or
pets</a>? Recreation of
a failing server should be easier than duct-taping a failing
one. Beware of <a href=https://martinfowler.com/bliki/SnowflakeServer.html>snowflake
servers</a>!</p><h3 id=keep>21. Are you doing your best to keep your engineers?<a hidden class=anchor aria-hidden=true href=#keep>#</a></h3><blockquote><p>I&rsquo;ve built a lot of my success off finding these &ldquo;truly gifted&rdquo;
people, and not settling for &lsquo;B" and &ldquo;C&rdquo; players, but really going
for the &ldquo;A&rdquo; players. &mldr; I found that when you get enough &ldquo;A&rdquo;
players together, when you go through the incredible work to find
five of these &ldquo;A&rdquo; players, they REALLY like working with each other
because they have never had a chance to do that before. And, they
don&rsquo;t want to work with &ldquo;B&rdquo; and &ldquo;C&rdquo; players, and so it becomes
self-policing, and they only want to hire more &ldquo;A&rdquo; players, so you
build up these pockets of &ldquo;A&rdquo; players, and it propagates &mldr;"</p></blockquote><p>Steve Jobs</p><p>Hiring good engineers is very important but keeping them is too! The
best engineering teams share a common mindset. Engineers want to work
with other engineers sharing the same interests and approaching the
same goals. This creates a virtuous circle, engineers motivate each
other in order to achieve the best possible outcomes. Be careful
though, a single new hire can disturb an A-player team&rsquo;s
balance. That&rsquo;s why the hiring process is very important.</p><p>You should treat your engineers as first-class employees. Companies,
recognizing their value, provide tech-specific careers with
compensations comparable to high-management salary level.</p><p>Further, engineering managers play an essential role to keep your
engineers (happy). They should know how to code and share the same
engineering mindset. If your engineering managers are not technical
skilled, your engineers will not take them seriously. Worse yet, they
will leave at some point in time because they feel misunderstood.</p><p>You should strive to hire A players and to keep them.</p><h3 id=22-do-you-provide-the-best-technology-for-your-developers>22. Do you provide the best technology for your developers?<a hidden class=anchor aria-hidden=true href=#22-do-you-provide-the-best-technology-for-your-developers>#</a></h3><p>This points extends Joel&rsquo;s original ninth point &ldquo;Do you use the best
tools money can buy?&rdquo; Joel focused mainly on software tools running on
your local machine like IDEs, editors, compilers, debuggers and also
local hardware like a second monitor. All this make your programmers
happy and productive. While this is still true, nowadays it takes more
than local tooling to <em>keep</em> your developers happy.</p><p>A major pillar of productivity is going to the public cloud like
Amazon AWS or Microsoft Azure. Public clouds offer a great work
experience for your engineers. The self-service approach is
particularly important. Engineers can automate their application stack
via APIs and scripts, use the newest technology and operate the
complete system without writing tickets and getting approvals from
superiors. It enables your developers to take responsibility for the
full lifecyle of the application from design, to implementation, to
release and to operation. It&rsquo;s a great productivity booster. If you
cannot go to the public cloud due to legal or other restrictions,
beware of the <a href=https://architectelevator.com/cloud/enterprise-non-cloud/>on-prem enterprise
non-cloud</a>. The
<strong>enterprise non-cloud</strong> is a treacherous thing, it offers modern
software stacks like Kubernetes or Prometheus but is fails to deliver
the main advantages of the public cloud like real self-service with
APIs, elasticity, scalability and a pay-per-usage price model.</p><p>Other kind of tools are equally important, e.g. modern collaboration
tools like Google Docs or Office 365 which support parallel
collaboration at one document with multiple users, modern
communication tools like Slack and a contemporary version control
platform like <a href=https://github.com/>github</a> with integration for code
reviews, for CI pipelines and for the public cloud.</p><h3 id=23-do-you-focus-on-the-four-key-metrics>23. Do you focus on the four key metrics?<a hidden class=anchor aria-hidden=true href=#23-do-you-focus-on-the-four-key-metrics>#</a></h3><p>The best way to measure if your engineering department is top-notch,
are the four key metrics, defined in fantastic book
<a href=https://itrevolution.com/book/accelerate/>Accelerate</a>.</p><p>High performers strive for:</p><ol><li>Short lead time</li><li>High deployment frequency</li><li>Short mean time to restore (MTTR)</li><li>Low change fail percentage</li></ol><p>Some of the above metrics seem contradictory like high deployment
frequency and low change fail percentage. But according to the studies
of the <a href=https://services.google.com/fh/files/misc/state-of-devops-2019.pdf>DevOps
Report</a>
the best companies perform in <strong>all</strong> key metrics excellently.</p><p>If you look for improvements, it is critical to focus on these four
key points permanently. Don&rsquo;t fall prey to expensive agile
transformation methodologies like SAFe. Usually they promise a magical
and fast performance boost but often the impact turns out as
insignificant or even worsens the situation.</p><h3 id=24-do-you-empower-your-developers>24. Do you empower your developers?<a hidden class=anchor aria-hidden=true href=#24-do-you-empower-your-developers>#</a></h3><p>Many companies treat their developers as pure delivery teams,
i.e. they are used to implement features based on roadmaps defined by
leadership and product management departments. Why this is a bad idea,
see <a href=https://svpg.com/product-fail/>Marty Cagan&rsquo;s post &ldquo;why products
fail?&rdquo;</a>. With this approach you only
getting half of their value. Further companies think developer teams
can be easily replaced or even outsourced. They are treated as
mercenaries but as we know from <a href=https://svpg.com/missionaries-vs-mercenaries/>John
Doerr</a></p><blockquote><p>we need teams of missionaries, not teams of mercenaries.</p></blockquote><p>But for an outsourced IT, it is almost impossible to work in
missionary mode.</p><p>In order to get the most of you developer teams, you must hire
missionaries and empower them. Empowered developers are first-class
employees. Your developers are the best source of innovation because
they know the enabling technology. But it is hard to attract, identify
and to keep top talent. See, how to hire (11. from Joel&rsquo;s test) and
<a href=#keep>keep the best</a>.</p><p>Empowered developers should not only implement predefined features
from stakeholders but are invited to come up with their own solutions
to satisfy the customer needs. Therefore we should give developers
<strong>problems</strong> to solve, not features to implement. It is mandatory that
developers understand the business context. A quick self-check if you
have empowered developers:</p><ul><li>Can developers identify themselves with the customers?</li><li>Do they attend user tests regularly?</li><li>At best, do your developers use the application themselves?</li><li>Do they know the pains of the customers or are they shielded away by
a wall of stakeholders, business departments, program managers and
never have the chance to get in contact with customers?</li><li>Do your developers drive their own features or do they only get them
at the sprint-planning?</li></ul><p>Finally empowered engineers means a mindset change in the whole
company, see <a href=https://svpg.com/keys-to-successful-transformation/>Marty
Cagan</a>:</p><blockquote><p>(the company is) moving from a model where the technology teams
exist to “serve the business” to one where they exist to “serve the
customers, in ways that work for the business.</p></blockquote><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p><strong>Digital</strong> companies like Google, Amazon, Facebook, Microsoft or
Netflix have these traits in their blood and they live by these
standards already for decades. For them, &ldquo;software&rdquo; is their core
product, they cannot afford piling up technical debt since they would
cripple and risk their own future. This is well understood by them. In
contrary to non-digital companies with oldschool enterprise IT
departments and outsourced IT.</p><p>Non-digital enterprises never considered &ldquo;software&rdquo; as a competitive
advantage. But slowly even they understand that <a href=https://a16z.com/2011/08/20/why-software-is-eating-the-world/>&ldquo;software eats the
world&rdquo;</a>
and they want to do develop software in-house again. In such
situations, missing know-how and &ldquo;wrong&rdquo; people with lack of skills
are common. This article wants to be a simple and easy applicable
guideline for them to establish a good coding mentality and culture
with good practices. I hope you can apply the full test and gain some
insights about strengths, weaknesses and possible improvements in your
company or team.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://gerlacdt.github.io/tags/programming/>programming</a></li><li><a href=https://gerlacdt.github.io/tags/softwareengineering/>softwareengineering</a></li></ul><nav class=paginav><a class=prev href=https://gerlacdt.github.io/posts/product-management-quotes/><span class=title>« Prev Page</span><br><span>Product Management Quotes</span></a>
<a class=next href=https://gerlacdt.github.io/posts/google-testing-toilet/><span class=title>Next Page »</span><br><span>Google Testing Toilet Collection</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Writing better Code on twitter" href="https://twitter.com/intent/tweet/?text=Writing%20better%20Code&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fwriting-better-software%2f&hashtags=programming%2csoftwareengineering"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Writing better Code on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fwriting-better-software%2f&title=Writing%20better%20Code&summary=Writing%20better%20Code&source=https%3a%2f%2fgerlacdt.github.io%2fposts%2fwriting-better-software%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Writing better Code on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fwriting-better-software%2f&title=Writing%20better%20Code"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Writing better Code on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fgerlacdt.github.io%2fposts%2fwriting-better-software%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Writing better Code on whatsapp" href="https://api.whatsapp.com/send?text=Writing%20better%20Code%20-%20https%3a%2f%2fgerlacdt.github.io%2fposts%2fwriting-better-software%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Writing better Code on telegram" href="https://telegram.me/share/url?text=Writing%20better%20Code&url=https%3a%2f%2fgerlacdt.github.io%2fposts%2fwriting-better-software%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://gerlacdt.github.io/>Daniel's programming rants</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>